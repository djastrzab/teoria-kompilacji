Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> <empty>
Rule 2     start -> morestatements
Rule 3     morestatements -> block
Rule 4     morestatements -> statement morestatements
Rule 5     block -> statement
Rule 6     block -> { morestatements }
Rule 7     statement -> ifstatement
Rule 8     statement -> loop
Rule 9     statement -> expr ;
Rule 10    statement -> returnstatement ;
Rule 11    statement -> assignstatement ;
Rule 12    statement -> printstatement ;
Rule 13    statement -> BREAK ;
Rule 14    statement -> CONTINUE ;
Rule 15    returnstatement -> RETURN
Rule 16    returnstatement -> RETURN expr
Rule 17    printstatement -> PRINT printables
Rule 18    printables -> printable
Rule 19    printables -> printable , printables
Rule 20    printable -> expr
Rule 21    printable -> STRING
Rule 22    assignstatement -> assignable = expr
Rule 23    assignstatement -> assignable ASSIGNPLUS expr
Rule 24    assignstatement -> assignable ASSIGNMINUS expr
Rule 25    assignstatement -> assignable ASSIGNTIMES expr
Rule 26    assignstatement -> assignable ASSIGNDIVIDE expr
Rule 27    assignable -> ID
Rule 28    assignable -> ID [ expr , expr ]
Rule 29    expr -> assignable
Rule 30    expr -> INTNUMBER
Rule 31    expr -> FLOATNUMBER
Rule 32    expr -> - expr
Rule 33    expr -> expr '
Rule 34    expr -> specialmatrixword ( expr )
Rule 35    expr -> ( expr )
Rule 36    expr -> [ matrixinitializer ]
Rule 37    expr -> expr + expr
Rule 38    expr -> expr - expr
Rule 39    expr -> expr * expr
Rule 40    expr -> expr / expr
Rule 41    expr -> expr MPLUS expr
Rule 42    expr -> expr MMINUS expr
Rule 43    expr -> expr MTIMES expr
Rule 44    expr -> expr MDIVIDE expr
Rule 45    expr -> expr EQ expr
Rule 46    expr -> expr NEQ expr
Rule 47    expr -> expr > expr
Rule 48    expr -> expr < expr
Rule 49    expr -> expr LEQ expr
Rule 50    expr -> expr GEQ expr
Rule 51    specialmatrixword -> ZEROS
Rule 52    specialmatrixword -> ONES
Rule 53    specialmatrixword -> EYE
Rule 54    ifstatement -> IF ( expr ) block
Rule 55    ifstatement -> IF ( expr ) block ELSE block
Rule 56    loop -> forloop
Rule 57    loop -> whileloop
Rule 58    forloop -> FOR ID = rangeoperator block
Rule 59    whileloop -> WHILE ( expr ) block
Rule 60    rangeoperator -> expr : expr
Rule 61    matrixinitializer -> [ innerlist ]
Rule 62    matrixinitializer -> vector , [ innerlist ]
Rule 63    vector -> [ innerlist ]
Rule 64    vector -> vector , [ innerlist ]
Rule 65    innerlist -> expr
Rule 66    innerlist -> innerlist , expr

Terminals, with rules where they appear

'                    : 33
(                    : 34 35 54 55 59
)                    : 34 35 54 55 59
*                    : 39
+                    : 37
,                    : 19 28 62 64 66
-                    : 32 38
/                    : 40
:                    : 60
;                    : 9 10 11 12 13 14
<                    : 48
=                    : 22 58
>                    : 47
ASSIGNDIVIDE         : 26
ASSIGNMINUS          : 24
ASSIGNPLUS           : 23
ASSIGNTIMES          : 25
BREAK                : 13
CONTINUE             : 14
ELSE                 : 55
EQ                   : 45
EYE                  : 53
FLOATNUMBER          : 31
FOR                  : 58
GEQ                  : 50
ID                   : 27 28 58
IF                   : 54 55
INTNUMBER            : 30
LEQ                  : 49
MDIVIDE              : 44
MMINUS               : 42
MPLUS                : 41
MTIMES               : 43
NEQ                  : 46
ONES                 : 52
PRINT                : 17
RETURN               : 15 16
STRING               : 21
WHILE                : 59
ZEROS                : 51
[                    : 28 36 61 62 63 64
]                    : 28 36 61 62 63 64
error                : 
{                    : 6
}                    : 6

Nonterminals, with rules where they appear

assignable           : 22 23 24 25 26 29
assignstatement      : 11
block                : 3 54 55 55 58 59
expr                 : 9 16 20 22 23 24 25 26 28 28 32 33 34 35 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 54 55 59 60 60 65 66
forloop              : 56
ifstatement          : 7
innerlist            : 61 62 63 64 66
loop                 : 8
matrixinitializer    : 36
morestatements       : 2 4 6
printable            : 18 19
printables           : 17 19
printstatement       : 12
rangeoperator        : 58
returnstatement      : 10
specialmatrixword    : 34
start                : 0
statement            : 4 5
vector               : 62 64
whileloop            : 57

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> .
    (2) start -> . morestatements
    (3) morestatements -> . block
    (4) morestatements -> . statement morestatements
    (5) block -> . statement
    (6) block -> . { morestatements }
    (7) statement -> . ifstatement
    (8) statement -> . loop
    (9) statement -> . expr ;
    (10) statement -> . returnstatement ;
    (11) statement -> . assignstatement ;
    (12) statement -> . printstatement ;
    (13) statement -> . BREAK ;
    (14) statement -> . CONTINUE ;
    (54) ifstatement -> . IF ( expr ) block
    (55) ifstatement -> . IF ( expr ) block ELSE block
    (56) loop -> . forloop
    (57) loop -> . whileloop
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (15) returnstatement -> . RETURN
    (16) returnstatement -> . RETURN expr
    (22) assignstatement -> . assignable = expr
    (23) assignstatement -> . assignable ASSIGNPLUS expr
    (24) assignstatement -> . assignable ASSIGNMINUS expr
    (25) assignstatement -> . assignable ASSIGNTIMES expr
    (26) assignstatement -> . assignable ASSIGNDIVIDE expr
    (17) printstatement -> . PRINT printables
    (58) forloop -> . FOR ID = rangeoperator block
    (59) whileloop -> . WHILE ( expr ) block
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    $end            reduce using rule 1 (start -> .)
    {               shift and go to state 5
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 14
    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    RETURN          shift and go to state 24
    PRINT           shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 28
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    start                          shift and go to state 1
    morestatements                 shift and go to state 2
    block                          shift and go to state 3
    statement                      shift and go to state 4
    ifstatement                    shift and go to state 6
    loop                           shift and go to state 7
    expr                           shift and go to state 8
    returnstatement                shift and go to state 9
    assignstatement                shift and go to state 10
    printstatement                 shift and go to state 11
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assignable                     shift and go to state 18
    specialmatrixword              shift and go to state 22

state 1

    (0) S' -> start .



state 2

    (2) start -> morestatements .

    $end            reduce using rule 2 (start -> morestatements .)


state 3

    (3) morestatements -> block .

    $end            reduce using rule 3 (morestatements -> block .)
    }               reduce using rule 3 (morestatements -> block .)


state 4

    (4) morestatements -> statement . morestatements
    (5) block -> statement .
    (3) morestatements -> . block
    (4) morestatements -> . statement morestatements
    (5) block -> . statement
    (6) block -> . { morestatements }
    (7) statement -> . ifstatement
    (8) statement -> . loop
    (9) statement -> . expr ;
    (10) statement -> . returnstatement ;
    (11) statement -> . assignstatement ;
    (12) statement -> . printstatement ;
    (13) statement -> . BREAK ;
    (14) statement -> . CONTINUE ;
    (54) ifstatement -> . IF ( expr ) block
    (55) ifstatement -> . IF ( expr ) block ELSE block
    (56) loop -> . forloop
    (57) loop -> . whileloop
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (15) returnstatement -> . RETURN
    (16) returnstatement -> . RETURN expr
    (22) assignstatement -> . assignable = expr
    (23) assignstatement -> . assignable ASSIGNPLUS expr
    (24) assignstatement -> . assignable ASSIGNMINUS expr
    (25) assignstatement -> . assignable ASSIGNTIMES expr
    (26) assignstatement -> . assignable ASSIGNDIVIDE expr
    (17) printstatement -> . PRINT printables
    (58) forloop -> . FOR ID = rangeoperator block
    (59) whileloop -> . WHILE ( expr ) block
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    $end            reduce using rule 5 (block -> statement .)
    }               reduce using rule 5 (block -> statement .)
    {               shift and go to state 5
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 14
    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    RETURN          shift and go to state 24
    PRINT           shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 28
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    statement                      shift and go to state 4
    morestatements                 shift and go to state 32
    block                          shift and go to state 3
    ifstatement                    shift and go to state 6
    loop                           shift and go to state 7
    expr                           shift and go to state 8
    returnstatement                shift and go to state 9
    assignstatement                shift and go to state 10
    printstatement                 shift and go to state 11
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assignable                     shift and go to state 18
    specialmatrixword              shift and go to state 22

state 5

    (6) block -> { . morestatements }
    (3) morestatements -> . block
    (4) morestatements -> . statement morestatements
    (5) block -> . statement
    (6) block -> . { morestatements }
    (7) statement -> . ifstatement
    (8) statement -> . loop
    (9) statement -> . expr ;
    (10) statement -> . returnstatement ;
    (11) statement -> . assignstatement ;
    (12) statement -> . printstatement ;
    (13) statement -> . BREAK ;
    (14) statement -> . CONTINUE ;
    (54) ifstatement -> . IF ( expr ) block
    (55) ifstatement -> . IF ( expr ) block ELSE block
    (56) loop -> . forloop
    (57) loop -> . whileloop
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (15) returnstatement -> . RETURN
    (16) returnstatement -> . RETURN expr
    (22) assignstatement -> . assignable = expr
    (23) assignstatement -> . assignable ASSIGNPLUS expr
    (24) assignstatement -> . assignable ASSIGNMINUS expr
    (25) assignstatement -> . assignable ASSIGNTIMES expr
    (26) assignstatement -> . assignable ASSIGNDIVIDE expr
    (17) printstatement -> . PRINT printables
    (58) forloop -> . FOR ID = rangeoperator block
    (59) whileloop -> . WHILE ( expr ) block
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    {               shift and go to state 5
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 14
    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    RETURN          shift and go to state 24
    PRINT           shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 28
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    morestatements                 shift and go to state 33
    block                          shift and go to state 3
    statement                      shift and go to state 4
    ifstatement                    shift and go to state 6
    loop                           shift and go to state 7
    expr                           shift and go to state 8
    returnstatement                shift and go to state 9
    assignstatement                shift and go to state 10
    printstatement                 shift and go to state 11
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assignable                     shift and go to state 18
    specialmatrixword              shift and go to state 22

state 6

    (7) statement -> ifstatement .

    {               reduce using rule 7 (statement -> ifstatement .)
    BREAK           reduce using rule 7 (statement -> ifstatement .)
    CONTINUE        reduce using rule 7 (statement -> ifstatement .)
    IF              reduce using rule 7 (statement -> ifstatement .)
    INTNUMBER       reduce using rule 7 (statement -> ifstatement .)
    FLOATNUMBER     reduce using rule 7 (statement -> ifstatement .)
    -               reduce using rule 7 (statement -> ifstatement .)
    (               reduce using rule 7 (statement -> ifstatement .)
    [               reduce using rule 7 (statement -> ifstatement .)
    RETURN          reduce using rule 7 (statement -> ifstatement .)
    PRINT           reduce using rule 7 (statement -> ifstatement .)
    FOR             reduce using rule 7 (statement -> ifstatement .)
    WHILE           reduce using rule 7 (statement -> ifstatement .)
    ID              reduce using rule 7 (statement -> ifstatement .)
    ZEROS           reduce using rule 7 (statement -> ifstatement .)
    ONES            reduce using rule 7 (statement -> ifstatement .)
    EYE             reduce using rule 7 (statement -> ifstatement .)
    $end            reduce using rule 7 (statement -> ifstatement .)
    }               reduce using rule 7 (statement -> ifstatement .)
    ELSE            reduce using rule 7 (statement -> ifstatement .)


state 7

    (8) statement -> loop .

    {               reduce using rule 8 (statement -> loop .)
    BREAK           reduce using rule 8 (statement -> loop .)
    CONTINUE        reduce using rule 8 (statement -> loop .)
    IF              reduce using rule 8 (statement -> loop .)
    INTNUMBER       reduce using rule 8 (statement -> loop .)
    FLOATNUMBER     reduce using rule 8 (statement -> loop .)
    -               reduce using rule 8 (statement -> loop .)
    (               reduce using rule 8 (statement -> loop .)
    [               reduce using rule 8 (statement -> loop .)
    RETURN          reduce using rule 8 (statement -> loop .)
    PRINT           reduce using rule 8 (statement -> loop .)
    FOR             reduce using rule 8 (statement -> loop .)
    WHILE           reduce using rule 8 (statement -> loop .)
    ID              reduce using rule 8 (statement -> loop .)
    ZEROS           reduce using rule 8 (statement -> loop .)
    ONES            reduce using rule 8 (statement -> loop .)
    EYE             reduce using rule 8 (statement -> loop .)
    $end            reduce using rule 8 (statement -> loop .)
    }               reduce using rule 8 (statement -> loop .)
    ELSE            reduce using rule 8 (statement -> loop .)


state 8

    (9) statement -> expr . ;
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               shift and go to state 34
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 9

    (10) statement -> returnstatement . ;

    ;               shift and go to state 50


state 10

    (11) statement -> assignstatement . ;

    ;               shift and go to state 51


state 11

    (12) statement -> printstatement . ;

    ;               shift and go to state 52


state 12

    (13) statement -> BREAK . ;

    ;               shift and go to state 53


state 13

    (14) statement -> CONTINUE . ;

    ;               shift and go to state 54


state 14

    (54) ifstatement -> IF . ( expr ) block
    (55) ifstatement -> IF . ( expr ) block ELSE block

    (               shift and go to state 55


state 15

    (35) expr -> ( . expr )
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 56
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 16

    (56) loop -> forloop .

    {               reduce using rule 56 (loop -> forloop .)
    BREAK           reduce using rule 56 (loop -> forloop .)
    CONTINUE        reduce using rule 56 (loop -> forloop .)
    IF              reduce using rule 56 (loop -> forloop .)
    INTNUMBER       reduce using rule 56 (loop -> forloop .)
    FLOATNUMBER     reduce using rule 56 (loop -> forloop .)
    -               reduce using rule 56 (loop -> forloop .)
    (               reduce using rule 56 (loop -> forloop .)
    [               reduce using rule 56 (loop -> forloop .)
    RETURN          reduce using rule 56 (loop -> forloop .)
    PRINT           reduce using rule 56 (loop -> forloop .)
    FOR             reduce using rule 56 (loop -> forloop .)
    WHILE           reduce using rule 56 (loop -> forloop .)
    ID              reduce using rule 56 (loop -> forloop .)
    ZEROS           reduce using rule 56 (loop -> forloop .)
    ONES            reduce using rule 56 (loop -> forloop .)
    EYE             reduce using rule 56 (loop -> forloop .)
    $end            reduce using rule 56 (loop -> forloop .)
    }               reduce using rule 56 (loop -> forloop .)
    ELSE            reduce using rule 56 (loop -> forloop .)


state 17

    (57) loop -> whileloop .

    {               reduce using rule 57 (loop -> whileloop .)
    BREAK           reduce using rule 57 (loop -> whileloop .)
    CONTINUE        reduce using rule 57 (loop -> whileloop .)
    IF              reduce using rule 57 (loop -> whileloop .)
    INTNUMBER       reduce using rule 57 (loop -> whileloop .)
    FLOATNUMBER     reduce using rule 57 (loop -> whileloop .)
    -               reduce using rule 57 (loop -> whileloop .)
    (               reduce using rule 57 (loop -> whileloop .)
    [               reduce using rule 57 (loop -> whileloop .)
    RETURN          reduce using rule 57 (loop -> whileloop .)
    PRINT           reduce using rule 57 (loop -> whileloop .)
    FOR             reduce using rule 57 (loop -> whileloop .)
    WHILE           reduce using rule 57 (loop -> whileloop .)
    ID              reduce using rule 57 (loop -> whileloop .)
    ZEROS           reduce using rule 57 (loop -> whileloop .)
    ONES            reduce using rule 57 (loop -> whileloop .)
    EYE             reduce using rule 57 (loop -> whileloop .)
    $end            reduce using rule 57 (loop -> whileloop .)
    }               reduce using rule 57 (loop -> whileloop .)
    ELSE            reduce using rule 57 (loop -> whileloop .)


state 18

    (29) expr -> assignable .
    (22) assignstatement -> assignable . = expr
    (23) assignstatement -> assignable . ASSIGNPLUS expr
    (24) assignstatement -> assignable . ASSIGNMINUS expr
    (25) assignstatement -> assignable . ASSIGNTIMES expr
    (26) assignstatement -> assignable . ASSIGNDIVIDE expr

    ;               reduce using rule 29 (expr -> assignable .)
    '               reduce using rule 29 (expr -> assignable .)
    +               reduce using rule 29 (expr -> assignable .)
    -               reduce using rule 29 (expr -> assignable .)
    *               reduce using rule 29 (expr -> assignable .)
    /               reduce using rule 29 (expr -> assignable .)
    MPLUS           reduce using rule 29 (expr -> assignable .)
    MMINUS          reduce using rule 29 (expr -> assignable .)
    MTIMES          reduce using rule 29 (expr -> assignable .)
    MDIVIDE         reduce using rule 29 (expr -> assignable .)
    EQ              reduce using rule 29 (expr -> assignable .)
    NEQ             reduce using rule 29 (expr -> assignable .)
    >               reduce using rule 29 (expr -> assignable .)
    <               reduce using rule 29 (expr -> assignable .)
    LEQ             reduce using rule 29 (expr -> assignable .)
    GEQ             reduce using rule 29 (expr -> assignable .)
    =               shift and go to state 58
    ASSIGNPLUS      shift and go to state 59
    ASSIGNMINUS     shift and go to state 60
    ASSIGNTIMES     shift and go to state 61
    ASSIGNDIVIDE    shift and go to state 62


state 19

    (30) expr -> INTNUMBER .

    ;               reduce using rule 30 (expr -> INTNUMBER .)
    '               reduce using rule 30 (expr -> INTNUMBER .)
    +               reduce using rule 30 (expr -> INTNUMBER .)
    -               reduce using rule 30 (expr -> INTNUMBER .)
    *               reduce using rule 30 (expr -> INTNUMBER .)
    /               reduce using rule 30 (expr -> INTNUMBER .)
    MPLUS           reduce using rule 30 (expr -> INTNUMBER .)
    MMINUS          reduce using rule 30 (expr -> INTNUMBER .)
    MTIMES          reduce using rule 30 (expr -> INTNUMBER .)
    MDIVIDE         reduce using rule 30 (expr -> INTNUMBER .)
    EQ              reduce using rule 30 (expr -> INTNUMBER .)
    NEQ             reduce using rule 30 (expr -> INTNUMBER .)
    >               reduce using rule 30 (expr -> INTNUMBER .)
    <               reduce using rule 30 (expr -> INTNUMBER .)
    LEQ             reduce using rule 30 (expr -> INTNUMBER .)
    GEQ             reduce using rule 30 (expr -> INTNUMBER .)
    )               reduce using rule 30 (expr -> INTNUMBER .)
    ,               reduce using rule 30 (expr -> INTNUMBER .)
    ]               reduce using rule 30 (expr -> INTNUMBER .)
    :               reduce using rule 30 (expr -> INTNUMBER .)
    {               reduce using rule 30 (expr -> INTNUMBER .)
    BREAK           reduce using rule 30 (expr -> INTNUMBER .)
    CONTINUE        reduce using rule 30 (expr -> INTNUMBER .)
    IF              reduce using rule 30 (expr -> INTNUMBER .)
    INTNUMBER       reduce using rule 30 (expr -> INTNUMBER .)
    FLOATNUMBER     reduce using rule 30 (expr -> INTNUMBER .)
    (               reduce using rule 30 (expr -> INTNUMBER .)
    [               reduce using rule 30 (expr -> INTNUMBER .)
    RETURN          reduce using rule 30 (expr -> INTNUMBER .)
    PRINT           reduce using rule 30 (expr -> INTNUMBER .)
    FOR             reduce using rule 30 (expr -> INTNUMBER .)
    WHILE           reduce using rule 30 (expr -> INTNUMBER .)
    ID              reduce using rule 30 (expr -> INTNUMBER .)
    ZEROS           reduce using rule 30 (expr -> INTNUMBER .)
    ONES            reduce using rule 30 (expr -> INTNUMBER .)
    EYE             reduce using rule 30 (expr -> INTNUMBER .)


state 20

    (31) expr -> FLOATNUMBER .

    ;               reduce using rule 31 (expr -> FLOATNUMBER .)
    '               reduce using rule 31 (expr -> FLOATNUMBER .)
    +               reduce using rule 31 (expr -> FLOATNUMBER .)
    -               reduce using rule 31 (expr -> FLOATNUMBER .)
    *               reduce using rule 31 (expr -> FLOATNUMBER .)
    /               reduce using rule 31 (expr -> FLOATNUMBER .)
    MPLUS           reduce using rule 31 (expr -> FLOATNUMBER .)
    MMINUS          reduce using rule 31 (expr -> FLOATNUMBER .)
    MTIMES          reduce using rule 31 (expr -> FLOATNUMBER .)
    MDIVIDE         reduce using rule 31 (expr -> FLOATNUMBER .)
    EQ              reduce using rule 31 (expr -> FLOATNUMBER .)
    NEQ             reduce using rule 31 (expr -> FLOATNUMBER .)
    >               reduce using rule 31 (expr -> FLOATNUMBER .)
    <               reduce using rule 31 (expr -> FLOATNUMBER .)
    LEQ             reduce using rule 31 (expr -> FLOATNUMBER .)
    GEQ             reduce using rule 31 (expr -> FLOATNUMBER .)
    )               reduce using rule 31 (expr -> FLOATNUMBER .)
    ,               reduce using rule 31 (expr -> FLOATNUMBER .)
    ]               reduce using rule 31 (expr -> FLOATNUMBER .)
    :               reduce using rule 31 (expr -> FLOATNUMBER .)
    {               reduce using rule 31 (expr -> FLOATNUMBER .)
    BREAK           reduce using rule 31 (expr -> FLOATNUMBER .)
    CONTINUE        reduce using rule 31 (expr -> FLOATNUMBER .)
    IF              reduce using rule 31 (expr -> FLOATNUMBER .)
    INTNUMBER       reduce using rule 31 (expr -> FLOATNUMBER .)
    FLOATNUMBER     reduce using rule 31 (expr -> FLOATNUMBER .)
    (               reduce using rule 31 (expr -> FLOATNUMBER .)
    [               reduce using rule 31 (expr -> FLOATNUMBER .)
    RETURN          reduce using rule 31 (expr -> FLOATNUMBER .)
    PRINT           reduce using rule 31 (expr -> FLOATNUMBER .)
    FOR             reduce using rule 31 (expr -> FLOATNUMBER .)
    WHILE           reduce using rule 31 (expr -> FLOATNUMBER .)
    ID              reduce using rule 31 (expr -> FLOATNUMBER .)
    ZEROS           reduce using rule 31 (expr -> FLOATNUMBER .)
    ONES            reduce using rule 31 (expr -> FLOATNUMBER .)
    EYE             reduce using rule 31 (expr -> FLOATNUMBER .)


state 21

    (32) expr -> - . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 63
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 22

    (34) expr -> specialmatrixword . ( expr )

    (               shift and go to state 64


state 23

    (36) expr -> [ . matrixinitializer ]
    (61) matrixinitializer -> . [ innerlist ]
    (62) matrixinitializer -> . vector , [ innerlist ]
    (63) vector -> . [ innerlist ]
    (64) vector -> . vector , [ innerlist ]

    [               shift and go to state 65

    matrixinitializer              shift and go to state 66
    vector                         shift and go to state 67

state 24

    (15) returnstatement -> RETURN .
    (16) returnstatement -> RETURN . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    ;               reduce using rule 15 (returnstatement -> RETURN .)
    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 68
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 25

    (17) printstatement -> PRINT . printables
    (18) printables -> . printable
    (19) printables -> . printable , printables
    (20) printable -> . expr
    (21) printable -> . STRING
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    STRING          shift and go to state 72
    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    printables                     shift and go to state 69
    printable                      shift and go to state 70
    expr                           shift and go to state 71
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 26

    (58) forloop -> FOR . ID = rangeoperator block

    ID              shift and go to state 73


state 27

    (27) assignable -> ID .
    (28) assignable -> ID . [ expr , expr ]

  ! shift/reduce conflict for [ resolved as shift
    =               reduce using rule 27 (assignable -> ID .)
    ASSIGNPLUS      reduce using rule 27 (assignable -> ID .)
    ASSIGNMINUS     reduce using rule 27 (assignable -> ID .)
    ASSIGNTIMES     reduce using rule 27 (assignable -> ID .)
    ASSIGNDIVIDE    reduce using rule 27 (assignable -> ID .)
    ;               reduce using rule 27 (assignable -> ID .)
    '               reduce using rule 27 (assignable -> ID .)
    +               reduce using rule 27 (assignable -> ID .)
    -               reduce using rule 27 (assignable -> ID .)
    *               reduce using rule 27 (assignable -> ID .)
    /               reduce using rule 27 (assignable -> ID .)
    MPLUS           reduce using rule 27 (assignable -> ID .)
    MMINUS          reduce using rule 27 (assignable -> ID .)
    MTIMES          reduce using rule 27 (assignable -> ID .)
    MDIVIDE         reduce using rule 27 (assignable -> ID .)
    EQ              reduce using rule 27 (assignable -> ID .)
    NEQ             reduce using rule 27 (assignable -> ID .)
    >               reduce using rule 27 (assignable -> ID .)
    <               reduce using rule 27 (assignable -> ID .)
    LEQ             reduce using rule 27 (assignable -> ID .)
    GEQ             reduce using rule 27 (assignable -> ID .)
    )               reduce using rule 27 (assignable -> ID .)
    ,               reduce using rule 27 (assignable -> ID .)
    ]               reduce using rule 27 (assignable -> ID .)
    :               reduce using rule 27 (assignable -> ID .)
    {               reduce using rule 27 (assignable -> ID .)
    BREAK           reduce using rule 27 (assignable -> ID .)
    CONTINUE        reduce using rule 27 (assignable -> ID .)
    IF              reduce using rule 27 (assignable -> ID .)
    INTNUMBER       reduce using rule 27 (assignable -> ID .)
    FLOATNUMBER     reduce using rule 27 (assignable -> ID .)
    (               reduce using rule 27 (assignable -> ID .)
    RETURN          reduce using rule 27 (assignable -> ID .)
    PRINT           reduce using rule 27 (assignable -> ID .)
    FOR             reduce using rule 27 (assignable -> ID .)
    WHILE           reduce using rule 27 (assignable -> ID .)
    ID              reduce using rule 27 (assignable -> ID .)
    ZEROS           reduce using rule 27 (assignable -> ID .)
    ONES            reduce using rule 27 (assignable -> ID .)
    EYE             reduce using rule 27 (assignable -> ID .)
    [               shift and go to state 74

  ! [               [ reduce using rule 27 (assignable -> ID .) ]


state 28

    (59) whileloop -> WHILE . ( expr ) block

    (               shift and go to state 75


state 29

    (51) specialmatrixword -> ZEROS .

    (               reduce using rule 51 (specialmatrixword -> ZEROS .)


state 30

    (52) specialmatrixword -> ONES .

    (               reduce using rule 52 (specialmatrixword -> ONES .)


state 31

    (53) specialmatrixword -> EYE .

    (               reduce using rule 53 (specialmatrixword -> EYE .)


state 32

    (4) morestatements -> statement morestatements .

    $end            reduce using rule 4 (morestatements -> statement morestatements .)
    }               reduce using rule 4 (morestatements -> statement morestatements .)


state 33

    (6) block -> { morestatements . }

    }               shift and go to state 76


state 34

    (9) statement -> expr ; .

    {               reduce using rule 9 (statement -> expr ; .)
    BREAK           reduce using rule 9 (statement -> expr ; .)
    CONTINUE        reduce using rule 9 (statement -> expr ; .)
    IF              reduce using rule 9 (statement -> expr ; .)
    INTNUMBER       reduce using rule 9 (statement -> expr ; .)
    FLOATNUMBER     reduce using rule 9 (statement -> expr ; .)
    -               reduce using rule 9 (statement -> expr ; .)
    (               reduce using rule 9 (statement -> expr ; .)
    [               reduce using rule 9 (statement -> expr ; .)
    RETURN          reduce using rule 9 (statement -> expr ; .)
    PRINT           reduce using rule 9 (statement -> expr ; .)
    FOR             reduce using rule 9 (statement -> expr ; .)
    WHILE           reduce using rule 9 (statement -> expr ; .)
    ID              reduce using rule 9 (statement -> expr ; .)
    ZEROS           reduce using rule 9 (statement -> expr ; .)
    ONES            reduce using rule 9 (statement -> expr ; .)
    EYE             reduce using rule 9 (statement -> expr ; .)
    $end            reduce using rule 9 (statement -> expr ; .)
    }               reduce using rule 9 (statement -> expr ; .)
    ELSE            reduce using rule 9 (statement -> expr ; .)


state 35

    (33) expr -> expr ' .

    ;               reduce using rule 33 (expr -> expr ' .)
    '               reduce using rule 33 (expr -> expr ' .)
    +               reduce using rule 33 (expr -> expr ' .)
    -               reduce using rule 33 (expr -> expr ' .)
    *               reduce using rule 33 (expr -> expr ' .)
    /               reduce using rule 33 (expr -> expr ' .)
    MPLUS           reduce using rule 33 (expr -> expr ' .)
    MMINUS          reduce using rule 33 (expr -> expr ' .)
    MTIMES          reduce using rule 33 (expr -> expr ' .)
    MDIVIDE         reduce using rule 33 (expr -> expr ' .)
    EQ              reduce using rule 33 (expr -> expr ' .)
    NEQ             reduce using rule 33 (expr -> expr ' .)
    >               reduce using rule 33 (expr -> expr ' .)
    <               reduce using rule 33 (expr -> expr ' .)
    LEQ             reduce using rule 33 (expr -> expr ' .)
    GEQ             reduce using rule 33 (expr -> expr ' .)
    )               reduce using rule 33 (expr -> expr ' .)
    ,               reduce using rule 33 (expr -> expr ' .)
    ]               reduce using rule 33 (expr -> expr ' .)
    :               reduce using rule 33 (expr -> expr ' .)
    {               reduce using rule 33 (expr -> expr ' .)
    BREAK           reduce using rule 33 (expr -> expr ' .)
    CONTINUE        reduce using rule 33 (expr -> expr ' .)
    IF              reduce using rule 33 (expr -> expr ' .)
    INTNUMBER       reduce using rule 33 (expr -> expr ' .)
    FLOATNUMBER     reduce using rule 33 (expr -> expr ' .)
    (               reduce using rule 33 (expr -> expr ' .)
    [               reduce using rule 33 (expr -> expr ' .)
    RETURN          reduce using rule 33 (expr -> expr ' .)
    PRINT           reduce using rule 33 (expr -> expr ' .)
    FOR             reduce using rule 33 (expr -> expr ' .)
    WHILE           reduce using rule 33 (expr -> expr ' .)
    ID              reduce using rule 33 (expr -> expr ' .)
    ZEROS           reduce using rule 33 (expr -> expr ' .)
    ONES            reduce using rule 33 (expr -> expr ' .)
    EYE             reduce using rule 33 (expr -> expr ' .)


state 36

    (37) expr -> expr + . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 77
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 37

    (38) expr -> expr - . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 78
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 38

    (39) expr -> expr * . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 79
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 39

    (40) expr -> expr / . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 80
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 40

    (41) expr -> expr MPLUS . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 81
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 41

    (42) expr -> expr MMINUS . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 82
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 42

    (43) expr -> expr MTIMES . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 83
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 43

    (44) expr -> expr MDIVIDE . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 84
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 44

    (45) expr -> expr EQ . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 85
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 45

    (46) expr -> expr NEQ . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 86
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 46

    (47) expr -> expr > . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 87
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 47

    (48) expr -> expr < . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 88
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 48

    (49) expr -> expr LEQ . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 89
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 49

    (50) expr -> expr GEQ . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 90
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 50

    (10) statement -> returnstatement ; .

    {               reduce using rule 10 (statement -> returnstatement ; .)
    BREAK           reduce using rule 10 (statement -> returnstatement ; .)
    CONTINUE        reduce using rule 10 (statement -> returnstatement ; .)
    IF              reduce using rule 10 (statement -> returnstatement ; .)
    INTNUMBER       reduce using rule 10 (statement -> returnstatement ; .)
    FLOATNUMBER     reduce using rule 10 (statement -> returnstatement ; .)
    -               reduce using rule 10 (statement -> returnstatement ; .)
    (               reduce using rule 10 (statement -> returnstatement ; .)
    [               reduce using rule 10 (statement -> returnstatement ; .)
    RETURN          reduce using rule 10 (statement -> returnstatement ; .)
    PRINT           reduce using rule 10 (statement -> returnstatement ; .)
    FOR             reduce using rule 10 (statement -> returnstatement ; .)
    WHILE           reduce using rule 10 (statement -> returnstatement ; .)
    ID              reduce using rule 10 (statement -> returnstatement ; .)
    ZEROS           reduce using rule 10 (statement -> returnstatement ; .)
    ONES            reduce using rule 10 (statement -> returnstatement ; .)
    EYE             reduce using rule 10 (statement -> returnstatement ; .)
    $end            reduce using rule 10 (statement -> returnstatement ; .)
    }               reduce using rule 10 (statement -> returnstatement ; .)
    ELSE            reduce using rule 10 (statement -> returnstatement ; .)


state 51

    (11) statement -> assignstatement ; .

    {               reduce using rule 11 (statement -> assignstatement ; .)
    BREAK           reduce using rule 11 (statement -> assignstatement ; .)
    CONTINUE        reduce using rule 11 (statement -> assignstatement ; .)
    IF              reduce using rule 11 (statement -> assignstatement ; .)
    INTNUMBER       reduce using rule 11 (statement -> assignstatement ; .)
    FLOATNUMBER     reduce using rule 11 (statement -> assignstatement ; .)
    -               reduce using rule 11 (statement -> assignstatement ; .)
    (               reduce using rule 11 (statement -> assignstatement ; .)
    [               reduce using rule 11 (statement -> assignstatement ; .)
    RETURN          reduce using rule 11 (statement -> assignstatement ; .)
    PRINT           reduce using rule 11 (statement -> assignstatement ; .)
    FOR             reduce using rule 11 (statement -> assignstatement ; .)
    WHILE           reduce using rule 11 (statement -> assignstatement ; .)
    ID              reduce using rule 11 (statement -> assignstatement ; .)
    ZEROS           reduce using rule 11 (statement -> assignstatement ; .)
    ONES            reduce using rule 11 (statement -> assignstatement ; .)
    EYE             reduce using rule 11 (statement -> assignstatement ; .)
    $end            reduce using rule 11 (statement -> assignstatement ; .)
    }               reduce using rule 11 (statement -> assignstatement ; .)
    ELSE            reduce using rule 11 (statement -> assignstatement ; .)


state 52

    (12) statement -> printstatement ; .

    {               reduce using rule 12 (statement -> printstatement ; .)
    BREAK           reduce using rule 12 (statement -> printstatement ; .)
    CONTINUE        reduce using rule 12 (statement -> printstatement ; .)
    IF              reduce using rule 12 (statement -> printstatement ; .)
    INTNUMBER       reduce using rule 12 (statement -> printstatement ; .)
    FLOATNUMBER     reduce using rule 12 (statement -> printstatement ; .)
    -               reduce using rule 12 (statement -> printstatement ; .)
    (               reduce using rule 12 (statement -> printstatement ; .)
    [               reduce using rule 12 (statement -> printstatement ; .)
    RETURN          reduce using rule 12 (statement -> printstatement ; .)
    PRINT           reduce using rule 12 (statement -> printstatement ; .)
    FOR             reduce using rule 12 (statement -> printstatement ; .)
    WHILE           reduce using rule 12 (statement -> printstatement ; .)
    ID              reduce using rule 12 (statement -> printstatement ; .)
    ZEROS           reduce using rule 12 (statement -> printstatement ; .)
    ONES            reduce using rule 12 (statement -> printstatement ; .)
    EYE             reduce using rule 12 (statement -> printstatement ; .)
    $end            reduce using rule 12 (statement -> printstatement ; .)
    }               reduce using rule 12 (statement -> printstatement ; .)
    ELSE            reduce using rule 12 (statement -> printstatement ; .)


state 53

    (13) statement -> BREAK ; .

    {               reduce using rule 13 (statement -> BREAK ; .)
    BREAK           reduce using rule 13 (statement -> BREAK ; .)
    CONTINUE        reduce using rule 13 (statement -> BREAK ; .)
    IF              reduce using rule 13 (statement -> BREAK ; .)
    INTNUMBER       reduce using rule 13 (statement -> BREAK ; .)
    FLOATNUMBER     reduce using rule 13 (statement -> BREAK ; .)
    -               reduce using rule 13 (statement -> BREAK ; .)
    (               reduce using rule 13 (statement -> BREAK ; .)
    [               reduce using rule 13 (statement -> BREAK ; .)
    RETURN          reduce using rule 13 (statement -> BREAK ; .)
    PRINT           reduce using rule 13 (statement -> BREAK ; .)
    FOR             reduce using rule 13 (statement -> BREAK ; .)
    WHILE           reduce using rule 13 (statement -> BREAK ; .)
    ID              reduce using rule 13 (statement -> BREAK ; .)
    ZEROS           reduce using rule 13 (statement -> BREAK ; .)
    ONES            reduce using rule 13 (statement -> BREAK ; .)
    EYE             reduce using rule 13 (statement -> BREAK ; .)
    $end            reduce using rule 13 (statement -> BREAK ; .)
    }               reduce using rule 13 (statement -> BREAK ; .)
    ELSE            reduce using rule 13 (statement -> BREAK ; .)


state 54

    (14) statement -> CONTINUE ; .

    {               reduce using rule 14 (statement -> CONTINUE ; .)
    BREAK           reduce using rule 14 (statement -> CONTINUE ; .)
    CONTINUE        reduce using rule 14 (statement -> CONTINUE ; .)
    IF              reduce using rule 14 (statement -> CONTINUE ; .)
    INTNUMBER       reduce using rule 14 (statement -> CONTINUE ; .)
    FLOATNUMBER     reduce using rule 14 (statement -> CONTINUE ; .)
    -               reduce using rule 14 (statement -> CONTINUE ; .)
    (               reduce using rule 14 (statement -> CONTINUE ; .)
    [               reduce using rule 14 (statement -> CONTINUE ; .)
    RETURN          reduce using rule 14 (statement -> CONTINUE ; .)
    PRINT           reduce using rule 14 (statement -> CONTINUE ; .)
    FOR             reduce using rule 14 (statement -> CONTINUE ; .)
    WHILE           reduce using rule 14 (statement -> CONTINUE ; .)
    ID              reduce using rule 14 (statement -> CONTINUE ; .)
    ZEROS           reduce using rule 14 (statement -> CONTINUE ; .)
    ONES            reduce using rule 14 (statement -> CONTINUE ; .)
    EYE             reduce using rule 14 (statement -> CONTINUE ; .)
    $end            reduce using rule 14 (statement -> CONTINUE ; .)
    }               reduce using rule 14 (statement -> CONTINUE ; .)
    ELSE            reduce using rule 14 (statement -> CONTINUE ; .)


state 55

    (54) ifstatement -> IF ( . expr ) block
    (55) ifstatement -> IF ( . expr ) block ELSE block
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 91
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 56

    (35) expr -> ( expr . )
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    )               shift and go to state 92
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 57

    (29) expr -> assignable .

    )               reduce using rule 29 (expr -> assignable .)
    '               reduce using rule 29 (expr -> assignable .)
    +               reduce using rule 29 (expr -> assignable .)
    -               reduce using rule 29 (expr -> assignable .)
    *               reduce using rule 29 (expr -> assignable .)
    /               reduce using rule 29 (expr -> assignable .)
    MPLUS           reduce using rule 29 (expr -> assignable .)
    MMINUS          reduce using rule 29 (expr -> assignable .)
    MTIMES          reduce using rule 29 (expr -> assignable .)
    MDIVIDE         reduce using rule 29 (expr -> assignable .)
    EQ              reduce using rule 29 (expr -> assignable .)
    NEQ             reduce using rule 29 (expr -> assignable .)
    >               reduce using rule 29 (expr -> assignable .)
    <               reduce using rule 29 (expr -> assignable .)
    LEQ             reduce using rule 29 (expr -> assignable .)
    GEQ             reduce using rule 29 (expr -> assignable .)
    ;               reduce using rule 29 (expr -> assignable .)
    ,               reduce using rule 29 (expr -> assignable .)
    ]               reduce using rule 29 (expr -> assignable .)
    :               reduce using rule 29 (expr -> assignable .)
    {               reduce using rule 29 (expr -> assignable .)
    BREAK           reduce using rule 29 (expr -> assignable .)
    CONTINUE        reduce using rule 29 (expr -> assignable .)
    IF              reduce using rule 29 (expr -> assignable .)
    INTNUMBER       reduce using rule 29 (expr -> assignable .)
    FLOATNUMBER     reduce using rule 29 (expr -> assignable .)
    (               reduce using rule 29 (expr -> assignable .)
    [               reduce using rule 29 (expr -> assignable .)
    RETURN          reduce using rule 29 (expr -> assignable .)
    PRINT           reduce using rule 29 (expr -> assignable .)
    FOR             reduce using rule 29 (expr -> assignable .)
    WHILE           reduce using rule 29 (expr -> assignable .)
    ID              reduce using rule 29 (expr -> assignable .)
    ZEROS           reduce using rule 29 (expr -> assignable .)
    ONES            reduce using rule 29 (expr -> assignable .)
    EYE             reduce using rule 29 (expr -> assignable .)


state 58

    (22) assignstatement -> assignable = . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    assignable                     shift and go to state 57
    expr                           shift and go to state 93
    specialmatrixword              shift and go to state 22

state 59

    (23) assignstatement -> assignable ASSIGNPLUS . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    assignable                     shift and go to state 57
    expr                           shift and go to state 94
    specialmatrixword              shift and go to state 22

state 60

    (24) assignstatement -> assignable ASSIGNMINUS . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    assignable                     shift and go to state 57
    expr                           shift and go to state 95
    specialmatrixword              shift and go to state 22

state 61

    (25) assignstatement -> assignable ASSIGNTIMES . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    assignable                     shift and go to state 57
    expr                           shift and go to state 96
    specialmatrixword              shift and go to state 22

state 62

    (26) assignstatement -> assignable ASSIGNDIVIDE . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    assignable                     shift and go to state 57
    expr                           shift and go to state 97
    specialmatrixword              shift and go to state 22

state 63

    (32) expr -> - expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 32 (expr -> - expr .)
    '               reduce using rule 32 (expr -> - expr .)
    +               reduce using rule 32 (expr -> - expr .)
    -               reduce using rule 32 (expr -> - expr .)
    *               reduce using rule 32 (expr -> - expr .)
    /               reduce using rule 32 (expr -> - expr .)
    MPLUS           reduce using rule 32 (expr -> - expr .)
    MMINUS          reduce using rule 32 (expr -> - expr .)
    MTIMES          reduce using rule 32 (expr -> - expr .)
    MDIVIDE         reduce using rule 32 (expr -> - expr .)
    EQ              reduce using rule 32 (expr -> - expr .)
    NEQ             reduce using rule 32 (expr -> - expr .)
    >               reduce using rule 32 (expr -> - expr .)
    <               reduce using rule 32 (expr -> - expr .)
    LEQ             reduce using rule 32 (expr -> - expr .)
    GEQ             reduce using rule 32 (expr -> - expr .)
    )               reduce using rule 32 (expr -> - expr .)
    ,               reduce using rule 32 (expr -> - expr .)
    ]               reduce using rule 32 (expr -> - expr .)
    :               reduce using rule 32 (expr -> - expr .)
    {               reduce using rule 32 (expr -> - expr .)
    BREAK           reduce using rule 32 (expr -> - expr .)
    CONTINUE        reduce using rule 32 (expr -> - expr .)
    IF              reduce using rule 32 (expr -> - expr .)
    INTNUMBER       reduce using rule 32 (expr -> - expr .)
    FLOATNUMBER     reduce using rule 32 (expr -> - expr .)
    (               reduce using rule 32 (expr -> - expr .)
    [               reduce using rule 32 (expr -> - expr .)
    RETURN          reduce using rule 32 (expr -> - expr .)
    PRINT           reduce using rule 32 (expr -> - expr .)
    FOR             reduce using rule 32 (expr -> - expr .)
    WHILE           reduce using rule 32 (expr -> - expr .)
    ID              reduce using rule 32 (expr -> - expr .)
    ZEROS           reduce using rule 32 (expr -> - expr .)
    ONES            reduce using rule 32 (expr -> - expr .)
    EYE             reduce using rule 32 (expr -> - expr .)

  ! '               [ shift and go to state 35 ]
  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 37 ]
  ! *               [ shift and go to state 38 ]
  ! /               [ shift and go to state 39 ]
  ! MPLUS           [ shift and go to state 40 ]
  ! MMINUS          [ shift and go to state 41 ]
  ! MTIMES          [ shift and go to state 42 ]
  ! MDIVIDE         [ shift and go to state 43 ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 64

    (34) expr -> specialmatrixword ( . expr )
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    specialmatrixword              shift and go to state 22
    expr                           shift and go to state 98
    assignable                     shift and go to state 57

state 65

    (61) matrixinitializer -> [ . innerlist ]
    (63) vector -> [ . innerlist ]
    (65) innerlist -> . expr
    (66) innerlist -> . innerlist , expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    innerlist                      shift and go to state 99
    expr                           shift and go to state 100
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 66

    (36) expr -> [ matrixinitializer . ]

    ]               shift and go to state 101


state 67

    (62) matrixinitializer -> vector . , [ innerlist ]
    (64) vector -> vector . , [ innerlist ]

    ,               shift and go to state 102


state 68

    (16) returnstatement -> RETURN expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 16 (returnstatement -> RETURN expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 69

    (17) printstatement -> PRINT printables .

    ;               reduce using rule 17 (printstatement -> PRINT printables .)


state 70

    (18) printables -> printable .
    (19) printables -> printable . , printables

    ;               reduce using rule 18 (printables -> printable .)
    ,               shift and go to state 103


state 71

    (20) printable -> expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ,               reduce using rule 20 (printable -> expr .)
    ;               reduce using rule 20 (printable -> expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 72

    (21) printable -> STRING .

    ,               reduce using rule 21 (printable -> STRING .)
    ;               reduce using rule 21 (printable -> STRING .)


state 73

    (58) forloop -> FOR ID . = rangeoperator block

    =               shift and go to state 104


state 74

    (28) assignable -> ID [ . expr , expr ]
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 105
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 75

    (59) whileloop -> WHILE ( . expr ) block
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 106
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 76

    (6) block -> { morestatements } .

    $end            reduce using rule 6 (block -> { morestatements } .)
    }               reduce using rule 6 (block -> { morestatements } .)
    ELSE            reduce using rule 6 (block -> { morestatements } .)
    {               reduce using rule 6 (block -> { morestatements } .)
    BREAK           reduce using rule 6 (block -> { morestatements } .)
    CONTINUE        reduce using rule 6 (block -> { morestatements } .)
    IF              reduce using rule 6 (block -> { morestatements } .)
    INTNUMBER       reduce using rule 6 (block -> { morestatements } .)
    FLOATNUMBER     reduce using rule 6 (block -> { morestatements } .)
    -               reduce using rule 6 (block -> { morestatements } .)
    (               reduce using rule 6 (block -> { morestatements } .)
    [               reduce using rule 6 (block -> { morestatements } .)
    RETURN          reduce using rule 6 (block -> { morestatements } .)
    PRINT           reduce using rule 6 (block -> { morestatements } .)
    FOR             reduce using rule 6 (block -> { morestatements } .)
    WHILE           reduce using rule 6 (block -> { morestatements } .)
    ID              reduce using rule 6 (block -> { morestatements } .)
    ZEROS           reduce using rule 6 (block -> { morestatements } .)
    ONES            reduce using rule 6 (block -> { morestatements } .)
    EYE             reduce using rule 6 (block -> { morestatements } .)


state 77

    (37) expr -> expr + expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 37 (expr -> expr + expr .)
    +               reduce using rule 37 (expr -> expr + expr .)
    -               reduce using rule 37 (expr -> expr + expr .)
    MPLUS           reduce using rule 37 (expr -> expr + expr .)
    MMINUS          reduce using rule 37 (expr -> expr + expr .)
    EQ              reduce using rule 37 (expr -> expr + expr .)
    NEQ             reduce using rule 37 (expr -> expr + expr .)
    >               reduce using rule 37 (expr -> expr + expr .)
    <               reduce using rule 37 (expr -> expr + expr .)
    LEQ             reduce using rule 37 (expr -> expr + expr .)
    GEQ             reduce using rule 37 (expr -> expr + expr .)
    )               reduce using rule 37 (expr -> expr + expr .)
    ,               reduce using rule 37 (expr -> expr + expr .)
    ]               reduce using rule 37 (expr -> expr + expr .)
    :               reduce using rule 37 (expr -> expr + expr .)
    {               reduce using rule 37 (expr -> expr + expr .)
    BREAK           reduce using rule 37 (expr -> expr + expr .)
    CONTINUE        reduce using rule 37 (expr -> expr + expr .)
    IF              reduce using rule 37 (expr -> expr + expr .)
    INTNUMBER       reduce using rule 37 (expr -> expr + expr .)
    FLOATNUMBER     reduce using rule 37 (expr -> expr + expr .)
    (               reduce using rule 37 (expr -> expr + expr .)
    [               reduce using rule 37 (expr -> expr + expr .)
    RETURN          reduce using rule 37 (expr -> expr + expr .)
    PRINT           reduce using rule 37 (expr -> expr + expr .)
    FOR             reduce using rule 37 (expr -> expr + expr .)
    WHILE           reduce using rule 37 (expr -> expr + expr .)
    ID              reduce using rule 37 (expr -> expr + expr .)
    ZEROS           reduce using rule 37 (expr -> expr + expr .)
    ONES            reduce using rule 37 (expr -> expr + expr .)
    EYE             reduce using rule 37 (expr -> expr + expr .)
    '               shift and go to state 35
    *               shift and go to state 38
    /               shift and go to state 39
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43

  ! '               [ reduce using rule 37 (expr -> expr + expr .) ]
  ! *               [ reduce using rule 37 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 37 (expr -> expr + expr .) ]
  ! MTIMES          [ reduce using rule 37 (expr -> expr + expr .) ]
  ! MDIVIDE         [ reduce using rule 37 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 37 ]
  ! MPLUS           [ shift and go to state 40 ]
  ! MMINUS          [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 78

    (38) expr -> expr - expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 38 (expr -> expr - expr .)
    +               reduce using rule 38 (expr -> expr - expr .)
    -               reduce using rule 38 (expr -> expr - expr .)
    MPLUS           reduce using rule 38 (expr -> expr - expr .)
    MMINUS          reduce using rule 38 (expr -> expr - expr .)
    EQ              reduce using rule 38 (expr -> expr - expr .)
    NEQ             reduce using rule 38 (expr -> expr - expr .)
    >               reduce using rule 38 (expr -> expr - expr .)
    <               reduce using rule 38 (expr -> expr - expr .)
    LEQ             reduce using rule 38 (expr -> expr - expr .)
    GEQ             reduce using rule 38 (expr -> expr - expr .)
    )               reduce using rule 38 (expr -> expr - expr .)
    ,               reduce using rule 38 (expr -> expr - expr .)
    ]               reduce using rule 38 (expr -> expr - expr .)
    :               reduce using rule 38 (expr -> expr - expr .)
    {               reduce using rule 38 (expr -> expr - expr .)
    BREAK           reduce using rule 38 (expr -> expr - expr .)
    CONTINUE        reduce using rule 38 (expr -> expr - expr .)
    IF              reduce using rule 38 (expr -> expr - expr .)
    INTNUMBER       reduce using rule 38 (expr -> expr - expr .)
    FLOATNUMBER     reduce using rule 38 (expr -> expr - expr .)
    (               reduce using rule 38 (expr -> expr - expr .)
    [               reduce using rule 38 (expr -> expr - expr .)
    RETURN          reduce using rule 38 (expr -> expr - expr .)
    PRINT           reduce using rule 38 (expr -> expr - expr .)
    FOR             reduce using rule 38 (expr -> expr - expr .)
    WHILE           reduce using rule 38 (expr -> expr - expr .)
    ID              reduce using rule 38 (expr -> expr - expr .)
    ZEROS           reduce using rule 38 (expr -> expr - expr .)
    ONES            reduce using rule 38 (expr -> expr - expr .)
    EYE             reduce using rule 38 (expr -> expr - expr .)
    '               shift and go to state 35
    *               shift and go to state 38
    /               shift and go to state 39
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43

  ! '               [ reduce using rule 38 (expr -> expr - expr .) ]
  ! *               [ reduce using rule 38 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 38 (expr -> expr - expr .) ]
  ! MTIMES          [ reduce using rule 38 (expr -> expr - expr .) ]
  ! MDIVIDE         [ reduce using rule 38 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 37 ]
  ! MPLUS           [ shift and go to state 40 ]
  ! MMINUS          [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 79

    (39) expr -> expr * expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 39 (expr -> expr * expr .)
    +               reduce using rule 39 (expr -> expr * expr .)
    -               reduce using rule 39 (expr -> expr * expr .)
    *               reduce using rule 39 (expr -> expr * expr .)
    /               reduce using rule 39 (expr -> expr * expr .)
    MPLUS           reduce using rule 39 (expr -> expr * expr .)
    MMINUS          reduce using rule 39 (expr -> expr * expr .)
    MTIMES          reduce using rule 39 (expr -> expr * expr .)
    MDIVIDE         reduce using rule 39 (expr -> expr * expr .)
    EQ              reduce using rule 39 (expr -> expr * expr .)
    NEQ             reduce using rule 39 (expr -> expr * expr .)
    >               reduce using rule 39 (expr -> expr * expr .)
    <               reduce using rule 39 (expr -> expr * expr .)
    LEQ             reduce using rule 39 (expr -> expr * expr .)
    GEQ             reduce using rule 39 (expr -> expr * expr .)
    )               reduce using rule 39 (expr -> expr * expr .)
    ,               reduce using rule 39 (expr -> expr * expr .)
    ]               reduce using rule 39 (expr -> expr * expr .)
    :               reduce using rule 39 (expr -> expr * expr .)
    {               reduce using rule 39 (expr -> expr * expr .)
    BREAK           reduce using rule 39 (expr -> expr * expr .)
    CONTINUE        reduce using rule 39 (expr -> expr * expr .)
    IF              reduce using rule 39 (expr -> expr * expr .)
    INTNUMBER       reduce using rule 39 (expr -> expr * expr .)
    FLOATNUMBER     reduce using rule 39 (expr -> expr * expr .)
    (               reduce using rule 39 (expr -> expr * expr .)
    [               reduce using rule 39 (expr -> expr * expr .)
    RETURN          reduce using rule 39 (expr -> expr * expr .)
    PRINT           reduce using rule 39 (expr -> expr * expr .)
    FOR             reduce using rule 39 (expr -> expr * expr .)
    WHILE           reduce using rule 39 (expr -> expr * expr .)
    ID              reduce using rule 39 (expr -> expr * expr .)
    ZEROS           reduce using rule 39 (expr -> expr * expr .)
    ONES            reduce using rule 39 (expr -> expr * expr .)
    EYE             reduce using rule 39 (expr -> expr * expr .)
    '               shift and go to state 35

  ! '               [ reduce using rule 39 (expr -> expr * expr .) ]
  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 37 ]
  ! *               [ shift and go to state 38 ]
  ! /               [ shift and go to state 39 ]
  ! MPLUS           [ shift and go to state 40 ]
  ! MMINUS          [ shift and go to state 41 ]
  ! MTIMES          [ shift and go to state 42 ]
  ! MDIVIDE         [ shift and go to state 43 ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 80

    (40) expr -> expr / expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 40 (expr -> expr / expr .)
    +               reduce using rule 40 (expr -> expr / expr .)
    -               reduce using rule 40 (expr -> expr / expr .)
    *               reduce using rule 40 (expr -> expr / expr .)
    /               reduce using rule 40 (expr -> expr / expr .)
    MPLUS           reduce using rule 40 (expr -> expr / expr .)
    MMINUS          reduce using rule 40 (expr -> expr / expr .)
    MTIMES          reduce using rule 40 (expr -> expr / expr .)
    MDIVIDE         reduce using rule 40 (expr -> expr / expr .)
    EQ              reduce using rule 40 (expr -> expr / expr .)
    NEQ             reduce using rule 40 (expr -> expr / expr .)
    >               reduce using rule 40 (expr -> expr / expr .)
    <               reduce using rule 40 (expr -> expr / expr .)
    LEQ             reduce using rule 40 (expr -> expr / expr .)
    GEQ             reduce using rule 40 (expr -> expr / expr .)
    )               reduce using rule 40 (expr -> expr / expr .)
    ,               reduce using rule 40 (expr -> expr / expr .)
    ]               reduce using rule 40 (expr -> expr / expr .)
    :               reduce using rule 40 (expr -> expr / expr .)
    {               reduce using rule 40 (expr -> expr / expr .)
    BREAK           reduce using rule 40 (expr -> expr / expr .)
    CONTINUE        reduce using rule 40 (expr -> expr / expr .)
    IF              reduce using rule 40 (expr -> expr / expr .)
    INTNUMBER       reduce using rule 40 (expr -> expr / expr .)
    FLOATNUMBER     reduce using rule 40 (expr -> expr / expr .)
    (               reduce using rule 40 (expr -> expr / expr .)
    [               reduce using rule 40 (expr -> expr / expr .)
    RETURN          reduce using rule 40 (expr -> expr / expr .)
    PRINT           reduce using rule 40 (expr -> expr / expr .)
    FOR             reduce using rule 40 (expr -> expr / expr .)
    WHILE           reduce using rule 40 (expr -> expr / expr .)
    ID              reduce using rule 40 (expr -> expr / expr .)
    ZEROS           reduce using rule 40 (expr -> expr / expr .)
    ONES            reduce using rule 40 (expr -> expr / expr .)
    EYE             reduce using rule 40 (expr -> expr / expr .)
    '               shift and go to state 35

  ! '               [ reduce using rule 40 (expr -> expr / expr .) ]
  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 37 ]
  ! *               [ shift and go to state 38 ]
  ! /               [ shift and go to state 39 ]
  ! MPLUS           [ shift and go to state 40 ]
  ! MMINUS          [ shift and go to state 41 ]
  ! MTIMES          [ shift and go to state 42 ]
  ! MDIVIDE         [ shift and go to state 43 ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 81

    (41) expr -> expr MPLUS expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 41 (expr -> expr MPLUS expr .)
    +               reduce using rule 41 (expr -> expr MPLUS expr .)
    -               reduce using rule 41 (expr -> expr MPLUS expr .)
    MPLUS           reduce using rule 41 (expr -> expr MPLUS expr .)
    MMINUS          reduce using rule 41 (expr -> expr MPLUS expr .)
    EQ              reduce using rule 41 (expr -> expr MPLUS expr .)
    NEQ             reduce using rule 41 (expr -> expr MPLUS expr .)
    >               reduce using rule 41 (expr -> expr MPLUS expr .)
    <               reduce using rule 41 (expr -> expr MPLUS expr .)
    LEQ             reduce using rule 41 (expr -> expr MPLUS expr .)
    GEQ             reduce using rule 41 (expr -> expr MPLUS expr .)
    )               reduce using rule 41 (expr -> expr MPLUS expr .)
    ,               reduce using rule 41 (expr -> expr MPLUS expr .)
    ]               reduce using rule 41 (expr -> expr MPLUS expr .)
    :               reduce using rule 41 (expr -> expr MPLUS expr .)
    {               reduce using rule 41 (expr -> expr MPLUS expr .)
    BREAK           reduce using rule 41 (expr -> expr MPLUS expr .)
    CONTINUE        reduce using rule 41 (expr -> expr MPLUS expr .)
    IF              reduce using rule 41 (expr -> expr MPLUS expr .)
    INTNUMBER       reduce using rule 41 (expr -> expr MPLUS expr .)
    FLOATNUMBER     reduce using rule 41 (expr -> expr MPLUS expr .)
    (               reduce using rule 41 (expr -> expr MPLUS expr .)
    [               reduce using rule 41 (expr -> expr MPLUS expr .)
    RETURN          reduce using rule 41 (expr -> expr MPLUS expr .)
    PRINT           reduce using rule 41 (expr -> expr MPLUS expr .)
    FOR             reduce using rule 41 (expr -> expr MPLUS expr .)
    WHILE           reduce using rule 41 (expr -> expr MPLUS expr .)
    ID              reduce using rule 41 (expr -> expr MPLUS expr .)
    ZEROS           reduce using rule 41 (expr -> expr MPLUS expr .)
    ONES            reduce using rule 41 (expr -> expr MPLUS expr .)
    EYE             reduce using rule 41 (expr -> expr MPLUS expr .)
    '               shift and go to state 35
    *               shift and go to state 38
    /               shift and go to state 39
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43

  ! '               [ reduce using rule 41 (expr -> expr MPLUS expr .) ]
  ! *               [ reduce using rule 41 (expr -> expr MPLUS expr .) ]
  ! /               [ reduce using rule 41 (expr -> expr MPLUS expr .) ]
  ! MTIMES          [ reduce using rule 41 (expr -> expr MPLUS expr .) ]
  ! MDIVIDE         [ reduce using rule 41 (expr -> expr MPLUS expr .) ]
  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 37 ]
  ! MPLUS           [ shift and go to state 40 ]
  ! MMINUS          [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 82

    (42) expr -> expr MMINUS expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 42 (expr -> expr MMINUS expr .)
    +               reduce using rule 42 (expr -> expr MMINUS expr .)
    -               reduce using rule 42 (expr -> expr MMINUS expr .)
    MPLUS           reduce using rule 42 (expr -> expr MMINUS expr .)
    MMINUS          reduce using rule 42 (expr -> expr MMINUS expr .)
    EQ              reduce using rule 42 (expr -> expr MMINUS expr .)
    NEQ             reduce using rule 42 (expr -> expr MMINUS expr .)
    >               reduce using rule 42 (expr -> expr MMINUS expr .)
    <               reduce using rule 42 (expr -> expr MMINUS expr .)
    LEQ             reduce using rule 42 (expr -> expr MMINUS expr .)
    GEQ             reduce using rule 42 (expr -> expr MMINUS expr .)
    )               reduce using rule 42 (expr -> expr MMINUS expr .)
    ,               reduce using rule 42 (expr -> expr MMINUS expr .)
    ]               reduce using rule 42 (expr -> expr MMINUS expr .)
    :               reduce using rule 42 (expr -> expr MMINUS expr .)
    {               reduce using rule 42 (expr -> expr MMINUS expr .)
    BREAK           reduce using rule 42 (expr -> expr MMINUS expr .)
    CONTINUE        reduce using rule 42 (expr -> expr MMINUS expr .)
    IF              reduce using rule 42 (expr -> expr MMINUS expr .)
    INTNUMBER       reduce using rule 42 (expr -> expr MMINUS expr .)
    FLOATNUMBER     reduce using rule 42 (expr -> expr MMINUS expr .)
    (               reduce using rule 42 (expr -> expr MMINUS expr .)
    [               reduce using rule 42 (expr -> expr MMINUS expr .)
    RETURN          reduce using rule 42 (expr -> expr MMINUS expr .)
    PRINT           reduce using rule 42 (expr -> expr MMINUS expr .)
    FOR             reduce using rule 42 (expr -> expr MMINUS expr .)
    WHILE           reduce using rule 42 (expr -> expr MMINUS expr .)
    ID              reduce using rule 42 (expr -> expr MMINUS expr .)
    ZEROS           reduce using rule 42 (expr -> expr MMINUS expr .)
    ONES            reduce using rule 42 (expr -> expr MMINUS expr .)
    EYE             reduce using rule 42 (expr -> expr MMINUS expr .)
    '               shift and go to state 35
    *               shift and go to state 38
    /               shift and go to state 39
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43

  ! '               [ reduce using rule 42 (expr -> expr MMINUS expr .) ]
  ! *               [ reduce using rule 42 (expr -> expr MMINUS expr .) ]
  ! /               [ reduce using rule 42 (expr -> expr MMINUS expr .) ]
  ! MTIMES          [ reduce using rule 42 (expr -> expr MMINUS expr .) ]
  ! MDIVIDE         [ reduce using rule 42 (expr -> expr MMINUS expr .) ]
  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 37 ]
  ! MPLUS           [ shift and go to state 40 ]
  ! MMINUS          [ shift and go to state 41 ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 83

    (43) expr -> expr MTIMES expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 43 (expr -> expr MTIMES expr .)
    +               reduce using rule 43 (expr -> expr MTIMES expr .)
    -               reduce using rule 43 (expr -> expr MTIMES expr .)
    *               reduce using rule 43 (expr -> expr MTIMES expr .)
    /               reduce using rule 43 (expr -> expr MTIMES expr .)
    MPLUS           reduce using rule 43 (expr -> expr MTIMES expr .)
    MMINUS          reduce using rule 43 (expr -> expr MTIMES expr .)
    MTIMES          reduce using rule 43 (expr -> expr MTIMES expr .)
    MDIVIDE         reduce using rule 43 (expr -> expr MTIMES expr .)
    EQ              reduce using rule 43 (expr -> expr MTIMES expr .)
    NEQ             reduce using rule 43 (expr -> expr MTIMES expr .)
    >               reduce using rule 43 (expr -> expr MTIMES expr .)
    <               reduce using rule 43 (expr -> expr MTIMES expr .)
    LEQ             reduce using rule 43 (expr -> expr MTIMES expr .)
    GEQ             reduce using rule 43 (expr -> expr MTIMES expr .)
    )               reduce using rule 43 (expr -> expr MTIMES expr .)
    ,               reduce using rule 43 (expr -> expr MTIMES expr .)
    ]               reduce using rule 43 (expr -> expr MTIMES expr .)
    :               reduce using rule 43 (expr -> expr MTIMES expr .)
    {               reduce using rule 43 (expr -> expr MTIMES expr .)
    BREAK           reduce using rule 43 (expr -> expr MTIMES expr .)
    CONTINUE        reduce using rule 43 (expr -> expr MTIMES expr .)
    IF              reduce using rule 43 (expr -> expr MTIMES expr .)
    INTNUMBER       reduce using rule 43 (expr -> expr MTIMES expr .)
    FLOATNUMBER     reduce using rule 43 (expr -> expr MTIMES expr .)
    (               reduce using rule 43 (expr -> expr MTIMES expr .)
    [               reduce using rule 43 (expr -> expr MTIMES expr .)
    RETURN          reduce using rule 43 (expr -> expr MTIMES expr .)
    PRINT           reduce using rule 43 (expr -> expr MTIMES expr .)
    FOR             reduce using rule 43 (expr -> expr MTIMES expr .)
    WHILE           reduce using rule 43 (expr -> expr MTIMES expr .)
    ID              reduce using rule 43 (expr -> expr MTIMES expr .)
    ZEROS           reduce using rule 43 (expr -> expr MTIMES expr .)
    ONES            reduce using rule 43 (expr -> expr MTIMES expr .)
    EYE             reduce using rule 43 (expr -> expr MTIMES expr .)
    '               shift and go to state 35

  ! '               [ reduce using rule 43 (expr -> expr MTIMES expr .) ]
  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 37 ]
  ! *               [ shift and go to state 38 ]
  ! /               [ shift and go to state 39 ]
  ! MPLUS           [ shift and go to state 40 ]
  ! MMINUS          [ shift and go to state 41 ]
  ! MTIMES          [ shift and go to state 42 ]
  ! MDIVIDE         [ shift and go to state 43 ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 84

    (44) expr -> expr MDIVIDE expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    +               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    -               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    *               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    /               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    MPLUS           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    MMINUS          reduce using rule 44 (expr -> expr MDIVIDE expr .)
    MTIMES          reduce using rule 44 (expr -> expr MDIVIDE expr .)
    MDIVIDE         reduce using rule 44 (expr -> expr MDIVIDE expr .)
    EQ              reduce using rule 44 (expr -> expr MDIVIDE expr .)
    NEQ             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    >               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    <               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    LEQ             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    GEQ             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    )               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ,               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ]               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    :               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    {               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    BREAK           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    CONTINUE        reduce using rule 44 (expr -> expr MDIVIDE expr .)
    IF              reduce using rule 44 (expr -> expr MDIVIDE expr .)
    INTNUMBER       reduce using rule 44 (expr -> expr MDIVIDE expr .)
    FLOATNUMBER     reduce using rule 44 (expr -> expr MDIVIDE expr .)
    (               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    [               reduce using rule 44 (expr -> expr MDIVIDE expr .)
    RETURN          reduce using rule 44 (expr -> expr MDIVIDE expr .)
    PRINT           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    FOR             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    WHILE           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ID              reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ZEROS           reduce using rule 44 (expr -> expr MDIVIDE expr .)
    ONES            reduce using rule 44 (expr -> expr MDIVIDE expr .)
    EYE             reduce using rule 44 (expr -> expr MDIVIDE expr .)
    '               shift and go to state 35

  ! '               [ reduce using rule 44 (expr -> expr MDIVIDE expr .) ]
  ! +               [ shift and go to state 36 ]
  ! -               [ shift and go to state 37 ]
  ! *               [ shift and go to state 38 ]
  ! /               [ shift and go to state 39 ]
  ! MPLUS           [ shift and go to state 40 ]
  ! MMINUS          [ shift and go to state 41 ]
  ! MTIMES          [ shift and go to state 42 ]
  ! MDIVIDE         [ shift and go to state 43 ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 85

    (45) expr -> expr EQ expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 45 (expr -> expr EQ expr .)
    EQ              reduce using rule 45 (expr -> expr EQ expr .)
    NEQ             reduce using rule 45 (expr -> expr EQ expr .)
    >               reduce using rule 45 (expr -> expr EQ expr .)
    <               reduce using rule 45 (expr -> expr EQ expr .)
    LEQ             reduce using rule 45 (expr -> expr EQ expr .)
    GEQ             reduce using rule 45 (expr -> expr EQ expr .)
    )               reduce using rule 45 (expr -> expr EQ expr .)
    ,               reduce using rule 45 (expr -> expr EQ expr .)
    ]               reduce using rule 45 (expr -> expr EQ expr .)
    :               reduce using rule 45 (expr -> expr EQ expr .)
    {               reduce using rule 45 (expr -> expr EQ expr .)
    BREAK           reduce using rule 45 (expr -> expr EQ expr .)
    CONTINUE        reduce using rule 45 (expr -> expr EQ expr .)
    IF              reduce using rule 45 (expr -> expr EQ expr .)
    INTNUMBER       reduce using rule 45 (expr -> expr EQ expr .)
    FLOATNUMBER     reduce using rule 45 (expr -> expr EQ expr .)
    (               reduce using rule 45 (expr -> expr EQ expr .)
    [               reduce using rule 45 (expr -> expr EQ expr .)
    RETURN          reduce using rule 45 (expr -> expr EQ expr .)
    PRINT           reduce using rule 45 (expr -> expr EQ expr .)
    FOR             reduce using rule 45 (expr -> expr EQ expr .)
    WHILE           reduce using rule 45 (expr -> expr EQ expr .)
    ID              reduce using rule 45 (expr -> expr EQ expr .)
    ZEROS           reduce using rule 45 (expr -> expr EQ expr .)
    ONES            reduce using rule 45 (expr -> expr EQ expr .)
    EYE             reduce using rule 45 (expr -> expr EQ expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43

  ! '               [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! +               [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! MPLUS           [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! MMINUS          [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! MTIMES          [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! MDIVIDE         [ reduce using rule 45 (expr -> expr EQ expr .) ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 86

    (46) expr -> expr NEQ expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 46 (expr -> expr NEQ expr .)
    EQ              reduce using rule 46 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 46 (expr -> expr NEQ expr .)
    >               reduce using rule 46 (expr -> expr NEQ expr .)
    <               reduce using rule 46 (expr -> expr NEQ expr .)
    LEQ             reduce using rule 46 (expr -> expr NEQ expr .)
    GEQ             reduce using rule 46 (expr -> expr NEQ expr .)
    )               reduce using rule 46 (expr -> expr NEQ expr .)
    ,               reduce using rule 46 (expr -> expr NEQ expr .)
    ]               reduce using rule 46 (expr -> expr NEQ expr .)
    :               reduce using rule 46 (expr -> expr NEQ expr .)
    {               reduce using rule 46 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 46 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 46 (expr -> expr NEQ expr .)
    IF              reduce using rule 46 (expr -> expr NEQ expr .)
    INTNUMBER       reduce using rule 46 (expr -> expr NEQ expr .)
    FLOATNUMBER     reduce using rule 46 (expr -> expr NEQ expr .)
    (               reduce using rule 46 (expr -> expr NEQ expr .)
    [               reduce using rule 46 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 46 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 46 (expr -> expr NEQ expr .)
    FOR             reduce using rule 46 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 46 (expr -> expr NEQ expr .)
    ID              reduce using rule 46 (expr -> expr NEQ expr .)
    ZEROS           reduce using rule 46 (expr -> expr NEQ expr .)
    ONES            reduce using rule 46 (expr -> expr NEQ expr .)
    EYE             reduce using rule 46 (expr -> expr NEQ expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43

  ! '               [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! +               [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! MPLUS           [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! MMINUS          [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! MTIMES          [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! MDIVIDE         [ reduce using rule 46 (expr -> expr NEQ expr .) ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 87

    (47) expr -> expr > expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 47 (expr -> expr > expr .)
    EQ              reduce using rule 47 (expr -> expr > expr .)
    NEQ             reduce using rule 47 (expr -> expr > expr .)
    >               reduce using rule 47 (expr -> expr > expr .)
    <               reduce using rule 47 (expr -> expr > expr .)
    LEQ             reduce using rule 47 (expr -> expr > expr .)
    GEQ             reduce using rule 47 (expr -> expr > expr .)
    )               reduce using rule 47 (expr -> expr > expr .)
    ,               reduce using rule 47 (expr -> expr > expr .)
    ]               reduce using rule 47 (expr -> expr > expr .)
    :               reduce using rule 47 (expr -> expr > expr .)
    {               reduce using rule 47 (expr -> expr > expr .)
    BREAK           reduce using rule 47 (expr -> expr > expr .)
    CONTINUE        reduce using rule 47 (expr -> expr > expr .)
    IF              reduce using rule 47 (expr -> expr > expr .)
    INTNUMBER       reduce using rule 47 (expr -> expr > expr .)
    FLOATNUMBER     reduce using rule 47 (expr -> expr > expr .)
    (               reduce using rule 47 (expr -> expr > expr .)
    [               reduce using rule 47 (expr -> expr > expr .)
    RETURN          reduce using rule 47 (expr -> expr > expr .)
    PRINT           reduce using rule 47 (expr -> expr > expr .)
    FOR             reduce using rule 47 (expr -> expr > expr .)
    WHILE           reduce using rule 47 (expr -> expr > expr .)
    ID              reduce using rule 47 (expr -> expr > expr .)
    ZEROS           reduce using rule 47 (expr -> expr > expr .)
    ONES            reduce using rule 47 (expr -> expr > expr .)
    EYE             reduce using rule 47 (expr -> expr > expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43

  ! '               [ reduce using rule 47 (expr -> expr > expr .) ]
  ! +               [ reduce using rule 47 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 47 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 47 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 47 (expr -> expr > expr .) ]
  ! MPLUS           [ reduce using rule 47 (expr -> expr > expr .) ]
  ! MMINUS          [ reduce using rule 47 (expr -> expr > expr .) ]
  ! MTIMES          [ reduce using rule 47 (expr -> expr > expr .) ]
  ! MDIVIDE         [ reduce using rule 47 (expr -> expr > expr .) ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 88

    (48) expr -> expr < expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 48 (expr -> expr < expr .)
    EQ              reduce using rule 48 (expr -> expr < expr .)
    NEQ             reduce using rule 48 (expr -> expr < expr .)
    >               reduce using rule 48 (expr -> expr < expr .)
    <               reduce using rule 48 (expr -> expr < expr .)
    LEQ             reduce using rule 48 (expr -> expr < expr .)
    GEQ             reduce using rule 48 (expr -> expr < expr .)
    )               reduce using rule 48 (expr -> expr < expr .)
    ,               reduce using rule 48 (expr -> expr < expr .)
    ]               reduce using rule 48 (expr -> expr < expr .)
    :               reduce using rule 48 (expr -> expr < expr .)
    {               reduce using rule 48 (expr -> expr < expr .)
    BREAK           reduce using rule 48 (expr -> expr < expr .)
    CONTINUE        reduce using rule 48 (expr -> expr < expr .)
    IF              reduce using rule 48 (expr -> expr < expr .)
    INTNUMBER       reduce using rule 48 (expr -> expr < expr .)
    FLOATNUMBER     reduce using rule 48 (expr -> expr < expr .)
    (               reduce using rule 48 (expr -> expr < expr .)
    [               reduce using rule 48 (expr -> expr < expr .)
    RETURN          reduce using rule 48 (expr -> expr < expr .)
    PRINT           reduce using rule 48 (expr -> expr < expr .)
    FOR             reduce using rule 48 (expr -> expr < expr .)
    WHILE           reduce using rule 48 (expr -> expr < expr .)
    ID              reduce using rule 48 (expr -> expr < expr .)
    ZEROS           reduce using rule 48 (expr -> expr < expr .)
    ONES            reduce using rule 48 (expr -> expr < expr .)
    EYE             reduce using rule 48 (expr -> expr < expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43

  ! '               [ reduce using rule 48 (expr -> expr < expr .) ]
  ! +               [ reduce using rule 48 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 48 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 48 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 48 (expr -> expr < expr .) ]
  ! MPLUS           [ reduce using rule 48 (expr -> expr < expr .) ]
  ! MMINUS          [ reduce using rule 48 (expr -> expr < expr .) ]
  ! MTIMES          [ reduce using rule 48 (expr -> expr < expr .) ]
  ! MDIVIDE         [ reduce using rule 48 (expr -> expr < expr .) ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 89

    (49) expr -> expr LEQ expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 49 (expr -> expr LEQ expr .)
    EQ              reduce using rule 49 (expr -> expr LEQ expr .)
    NEQ             reduce using rule 49 (expr -> expr LEQ expr .)
    >               reduce using rule 49 (expr -> expr LEQ expr .)
    <               reduce using rule 49 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 49 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 49 (expr -> expr LEQ expr .)
    )               reduce using rule 49 (expr -> expr LEQ expr .)
    ,               reduce using rule 49 (expr -> expr LEQ expr .)
    ]               reduce using rule 49 (expr -> expr LEQ expr .)
    :               reduce using rule 49 (expr -> expr LEQ expr .)
    {               reduce using rule 49 (expr -> expr LEQ expr .)
    BREAK           reduce using rule 49 (expr -> expr LEQ expr .)
    CONTINUE        reduce using rule 49 (expr -> expr LEQ expr .)
    IF              reduce using rule 49 (expr -> expr LEQ expr .)
    INTNUMBER       reduce using rule 49 (expr -> expr LEQ expr .)
    FLOATNUMBER     reduce using rule 49 (expr -> expr LEQ expr .)
    (               reduce using rule 49 (expr -> expr LEQ expr .)
    [               reduce using rule 49 (expr -> expr LEQ expr .)
    RETURN          reduce using rule 49 (expr -> expr LEQ expr .)
    PRINT           reduce using rule 49 (expr -> expr LEQ expr .)
    FOR             reduce using rule 49 (expr -> expr LEQ expr .)
    WHILE           reduce using rule 49 (expr -> expr LEQ expr .)
    ID              reduce using rule 49 (expr -> expr LEQ expr .)
    ZEROS           reduce using rule 49 (expr -> expr LEQ expr .)
    ONES            reduce using rule 49 (expr -> expr LEQ expr .)
    EYE             reduce using rule 49 (expr -> expr LEQ expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43

  ! '               [ reduce using rule 49 (expr -> expr LEQ expr .) ]
  ! +               [ reduce using rule 49 (expr -> expr LEQ expr .) ]
  ! -               [ reduce using rule 49 (expr -> expr LEQ expr .) ]
  ! *               [ reduce using rule 49 (expr -> expr LEQ expr .) ]
  ! /               [ reduce using rule 49 (expr -> expr LEQ expr .) ]
  ! MPLUS           [ reduce using rule 49 (expr -> expr LEQ expr .) ]
  ! MMINUS          [ reduce using rule 49 (expr -> expr LEQ expr .) ]
  ! MTIMES          [ reduce using rule 49 (expr -> expr LEQ expr .) ]
  ! MDIVIDE         [ reduce using rule 49 (expr -> expr LEQ expr .) ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 90

    (50) expr -> expr GEQ expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 50 (expr -> expr GEQ expr .)
    EQ              reduce using rule 50 (expr -> expr GEQ expr .)
    NEQ             reduce using rule 50 (expr -> expr GEQ expr .)
    >               reduce using rule 50 (expr -> expr GEQ expr .)
    <               reduce using rule 50 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 50 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 50 (expr -> expr GEQ expr .)
    )               reduce using rule 50 (expr -> expr GEQ expr .)
    ,               reduce using rule 50 (expr -> expr GEQ expr .)
    ]               reduce using rule 50 (expr -> expr GEQ expr .)
    :               reduce using rule 50 (expr -> expr GEQ expr .)
    {               reduce using rule 50 (expr -> expr GEQ expr .)
    BREAK           reduce using rule 50 (expr -> expr GEQ expr .)
    CONTINUE        reduce using rule 50 (expr -> expr GEQ expr .)
    IF              reduce using rule 50 (expr -> expr GEQ expr .)
    INTNUMBER       reduce using rule 50 (expr -> expr GEQ expr .)
    FLOATNUMBER     reduce using rule 50 (expr -> expr GEQ expr .)
    (               reduce using rule 50 (expr -> expr GEQ expr .)
    [               reduce using rule 50 (expr -> expr GEQ expr .)
    RETURN          reduce using rule 50 (expr -> expr GEQ expr .)
    PRINT           reduce using rule 50 (expr -> expr GEQ expr .)
    FOR             reduce using rule 50 (expr -> expr GEQ expr .)
    WHILE           reduce using rule 50 (expr -> expr GEQ expr .)
    ID              reduce using rule 50 (expr -> expr GEQ expr .)
    ZEROS           reduce using rule 50 (expr -> expr GEQ expr .)
    ONES            reduce using rule 50 (expr -> expr GEQ expr .)
    EYE             reduce using rule 50 (expr -> expr GEQ expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43

  ! '               [ reduce using rule 50 (expr -> expr GEQ expr .) ]
  ! +               [ reduce using rule 50 (expr -> expr GEQ expr .) ]
  ! -               [ reduce using rule 50 (expr -> expr GEQ expr .) ]
  ! *               [ reduce using rule 50 (expr -> expr GEQ expr .) ]
  ! /               [ reduce using rule 50 (expr -> expr GEQ expr .) ]
  ! MPLUS           [ reduce using rule 50 (expr -> expr GEQ expr .) ]
  ! MMINUS          [ reduce using rule 50 (expr -> expr GEQ expr .) ]
  ! MTIMES          [ reduce using rule 50 (expr -> expr GEQ expr .) ]
  ! MDIVIDE         [ reduce using rule 50 (expr -> expr GEQ expr .) ]
  ! EQ              [ shift and go to state 44 ]
  ! NEQ             [ shift and go to state 45 ]
  ! >               [ shift and go to state 46 ]
  ! <               [ shift and go to state 47 ]
  ! LEQ             [ shift and go to state 48 ]
  ! GEQ             [ shift and go to state 49 ]


state 91

    (54) ifstatement -> IF ( expr . ) block
    (55) ifstatement -> IF ( expr . ) block ELSE block
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    )               shift and go to state 107
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 92

    (35) expr -> ( expr ) .

    ;               reduce using rule 35 (expr -> ( expr ) .)
    '               reduce using rule 35 (expr -> ( expr ) .)
    +               reduce using rule 35 (expr -> ( expr ) .)
    -               reduce using rule 35 (expr -> ( expr ) .)
    *               reduce using rule 35 (expr -> ( expr ) .)
    /               reduce using rule 35 (expr -> ( expr ) .)
    MPLUS           reduce using rule 35 (expr -> ( expr ) .)
    MMINUS          reduce using rule 35 (expr -> ( expr ) .)
    MTIMES          reduce using rule 35 (expr -> ( expr ) .)
    MDIVIDE         reduce using rule 35 (expr -> ( expr ) .)
    EQ              reduce using rule 35 (expr -> ( expr ) .)
    NEQ             reduce using rule 35 (expr -> ( expr ) .)
    >               reduce using rule 35 (expr -> ( expr ) .)
    <               reduce using rule 35 (expr -> ( expr ) .)
    LEQ             reduce using rule 35 (expr -> ( expr ) .)
    GEQ             reduce using rule 35 (expr -> ( expr ) .)
    )               reduce using rule 35 (expr -> ( expr ) .)
    ,               reduce using rule 35 (expr -> ( expr ) .)
    ]               reduce using rule 35 (expr -> ( expr ) .)
    :               reduce using rule 35 (expr -> ( expr ) .)
    {               reduce using rule 35 (expr -> ( expr ) .)
    BREAK           reduce using rule 35 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 35 (expr -> ( expr ) .)
    IF              reduce using rule 35 (expr -> ( expr ) .)
    INTNUMBER       reduce using rule 35 (expr -> ( expr ) .)
    FLOATNUMBER     reduce using rule 35 (expr -> ( expr ) .)
    (               reduce using rule 35 (expr -> ( expr ) .)
    [               reduce using rule 35 (expr -> ( expr ) .)
    RETURN          reduce using rule 35 (expr -> ( expr ) .)
    PRINT           reduce using rule 35 (expr -> ( expr ) .)
    FOR             reduce using rule 35 (expr -> ( expr ) .)
    WHILE           reduce using rule 35 (expr -> ( expr ) .)
    ID              reduce using rule 35 (expr -> ( expr ) .)
    ZEROS           reduce using rule 35 (expr -> ( expr ) .)
    ONES            reduce using rule 35 (expr -> ( expr ) .)
    EYE             reduce using rule 35 (expr -> ( expr ) .)


state 93

    (22) assignstatement -> assignable = expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 22 (assignstatement -> assignable = expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 94

    (23) assignstatement -> assignable ASSIGNPLUS expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 23 (assignstatement -> assignable ASSIGNPLUS expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 95

    (24) assignstatement -> assignable ASSIGNMINUS expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 24 (assignstatement -> assignable ASSIGNMINUS expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 96

    (25) assignstatement -> assignable ASSIGNTIMES expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 25 (assignstatement -> assignable ASSIGNTIMES expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 97

    (26) assignstatement -> assignable ASSIGNDIVIDE expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ;               reduce using rule 26 (assignstatement -> assignable ASSIGNDIVIDE expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 98

    (34) expr -> specialmatrixword ( expr . )
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    )               shift and go to state 108
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 99

    (61) matrixinitializer -> [ innerlist . ]
    (63) vector -> [ innerlist . ]
    (66) innerlist -> innerlist . , expr

    ]               shift and go to state 109
    ,               shift and go to state 110


state 100

    (65) innerlist -> expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ]               reduce using rule 65 (innerlist -> expr .)
    ,               reduce using rule 65 (innerlist -> expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 101

    (36) expr -> [ matrixinitializer ] .

    ;               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    '               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    +               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    -               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    *               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    /               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    MPLUS           reduce using rule 36 (expr -> [ matrixinitializer ] .)
    MMINUS          reduce using rule 36 (expr -> [ matrixinitializer ] .)
    MTIMES          reduce using rule 36 (expr -> [ matrixinitializer ] .)
    MDIVIDE         reduce using rule 36 (expr -> [ matrixinitializer ] .)
    EQ              reduce using rule 36 (expr -> [ matrixinitializer ] .)
    NEQ             reduce using rule 36 (expr -> [ matrixinitializer ] .)
    >               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    <               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    LEQ             reduce using rule 36 (expr -> [ matrixinitializer ] .)
    GEQ             reduce using rule 36 (expr -> [ matrixinitializer ] .)
    )               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    ,               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    ]               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    :               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    {               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    BREAK           reduce using rule 36 (expr -> [ matrixinitializer ] .)
    CONTINUE        reduce using rule 36 (expr -> [ matrixinitializer ] .)
    IF              reduce using rule 36 (expr -> [ matrixinitializer ] .)
    INTNUMBER       reduce using rule 36 (expr -> [ matrixinitializer ] .)
    FLOATNUMBER     reduce using rule 36 (expr -> [ matrixinitializer ] .)
    (               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    [               reduce using rule 36 (expr -> [ matrixinitializer ] .)
    RETURN          reduce using rule 36 (expr -> [ matrixinitializer ] .)
    PRINT           reduce using rule 36 (expr -> [ matrixinitializer ] .)
    FOR             reduce using rule 36 (expr -> [ matrixinitializer ] .)
    WHILE           reduce using rule 36 (expr -> [ matrixinitializer ] .)
    ID              reduce using rule 36 (expr -> [ matrixinitializer ] .)
    ZEROS           reduce using rule 36 (expr -> [ matrixinitializer ] .)
    ONES            reduce using rule 36 (expr -> [ matrixinitializer ] .)
    EYE             reduce using rule 36 (expr -> [ matrixinitializer ] .)


state 102

    (62) matrixinitializer -> vector , . [ innerlist ]
    (64) vector -> vector , . [ innerlist ]

    [               shift and go to state 111


state 103

    (19) printables -> printable , . printables
    (18) printables -> . printable
    (19) printables -> . printable , printables
    (20) printable -> . expr
    (21) printable -> . STRING
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    STRING          shift and go to state 72
    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    printable                      shift and go to state 70
    printables                     shift and go to state 112
    expr                           shift and go to state 71
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 104

    (58) forloop -> FOR ID = . rangeoperator block
    (60) rangeoperator -> . expr : expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    rangeoperator                  shift and go to state 113
    expr                           shift and go to state 114
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 105

    (28) assignable -> ID [ expr . , expr ]
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ,               shift and go to state 115
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 106

    (59) whileloop -> WHILE ( expr . ) block
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    )               shift and go to state 116
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 107

    (54) ifstatement -> IF ( expr ) . block
    (55) ifstatement -> IF ( expr ) . block ELSE block
    (5) block -> . statement
    (6) block -> . { morestatements }
    (7) statement -> . ifstatement
    (8) statement -> . loop
    (9) statement -> . expr ;
    (10) statement -> . returnstatement ;
    (11) statement -> . assignstatement ;
    (12) statement -> . printstatement ;
    (13) statement -> . BREAK ;
    (14) statement -> . CONTINUE ;
    (54) ifstatement -> . IF ( expr ) block
    (55) ifstatement -> . IF ( expr ) block ELSE block
    (56) loop -> . forloop
    (57) loop -> . whileloop
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (15) returnstatement -> . RETURN
    (16) returnstatement -> . RETURN expr
    (22) assignstatement -> . assignable = expr
    (23) assignstatement -> . assignable ASSIGNPLUS expr
    (24) assignstatement -> . assignable ASSIGNMINUS expr
    (25) assignstatement -> . assignable ASSIGNTIMES expr
    (26) assignstatement -> . assignable ASSIGNDIVIDE expr
    (17) printstatement -> . PRINT printables
    (58) forloop -> . FOR ID = rangeoperator block
    (59) whileloop -> . WHILE ( expr ) block
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    {               shift and go to state 5
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 14
    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    RETURN          shift and go to state 24
    PRINT           shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 28
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 8
    block                          shift and go to state 117
    statement                      shift and go to state 118
    ifstatement                    shift and go to state 6
    loop                           shift and go to state 7
    returnstatement                shift and go to state 9
    assignstatement                shift and go to state 10
    printstatement                 shift and go to state 11
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assignable                     shift and go to state 18
    specialmatrixword              shift and go to state 22

state 108

    (34) expr -> specialmatrixword ( expr ) .

    ;               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    '               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    +               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    -               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    *               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    /               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    MPLUS           reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    MMINUS          reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    MTIMES          reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    MDIVIDE         reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    EQ              reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    NEQ             reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    >               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    <               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    LEQ             reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    GEQ             reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    )               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    ,               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    ]               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    :               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    {               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    BREAK           reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    CONTINUE        reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    IF              reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    INTNUMBER       reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    FLOATNUMBER     reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    (               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    [               reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    RETURN          reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    PRINT           reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    FOR             reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    WHILE           reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    ID              reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    ZEROS           reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    ONES            reduce using rule 34 (expr -> specialmatrixword ( expr ) .)
    EYE             reduce using rule 34 (expr -> specialmatrixword ( expr ) .)


state 109

    (61) matrixinitializer -> [ innerlist ] .
    (63) vector -> [ innerlist ] .

    ]               reduce using rule 61 (matrixinitializer -> [ innerlist ] .)
    ,               reduce using rule 63 (vector -> [ innerlist ] .)


state 110

    (66) innerlist -> innerlist , . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 119
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 111

    (62) matrixinitializer -> vector , [ . innerlist ]
    (64) vector -> vector , [ . innerlist ]
    (65) innerlist -> . expr
    (66) innerlist -> . innerlist , expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    innerlist                      shift and go to state 120
    expr                           shift and go to state 100
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 112

    (19) printables -> printable , printables .

    ;               reduce using rule 19 (printables -> printable , printables .)


state 113

    (58) forloop -> FOR ID = rangeoperator . block
    (5) block -> . statement
    (6) block -> . { morestatements }
    (7) statement -> . ifstatement
    (8) statement -> . loop
    (9) statement -> . expr ;
    (10) statement -> . returnstatement ;
    (11) statement -> . assignstatement ;
    (12) statement -> . printstatement ;
    (13) statement -> . BREAK ;
    (14) statement -> . CONTINUE ;
    (54) ifstatement -> . IF ( expr ) block
    (55) ifstatement -> . IF ( expr ) block ELSE block
    (56) loop -> . forloop
    (57) loop -> . whileloop
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (15) returnstatement -> . RETURN
    (16) returnstatement -> . RETURN expr
    (22) assignstatement -> . assignable = expr
    (23) assignstatement -> . assignable ASSIGNPLUS expr
    (24) assignstatement -> . assignable ASSIGNMINUS expr
    (25) assignstatement -> . assignable ASSIGNTIMES expr
    (26) assignstatement -> . assignable ASSIGNDIVIDE expr
    (17) printstatement -> . PRINT printables
    (58) forloop -> . FOR ID = rangeoperator block
    (59) whileloop -> . WHILE ( expr ) block
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    {               shift and go to state 5
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 14
    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    RETURN          shift and go to state 24
    PRINT           shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 28
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    block                          shift and go to state 121
    statement                      shift and go to state 118
    ifstatement                    shift and go to state 6
    loop                           shift and go to state 7
    expr                           shift and go to state 8
    returnstatement                shift and go to state 9
    assignstatement                shift and go to state 10
    printstatement                 shift and go to state 11
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assignable                     shift and go to state 18
    specialmatrixword              shift and go to state 22

state 114

    (60) rangeoperator -> expr . : expr
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    :               shift and go to state 122
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 115

    (28) assignable -> ID [ expr , . expr ]
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 123
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 116

    (59) whileloop -> WHILE ( expr ) . block
    (5) block -> . statement
    (6) block -> . { morestatements }
    (7) statement -> . ifstatement
    (8) statement -> . loop
    (9) statement -> . expr ;
    (10) statement -> . returnstatement ;
    (11) statement -> . assignstatement ;
    (12) statement -> . printstatement ;
    (13) statement -> . BREAK ;
    (14) statement -> . CONTINUE ;
    (54) ifstatement -> . IF ( expr ) block
    (55) ifstatement -> . IF ( expr ) block ELSE block
    (56) loop -> . forloop
    (57) loop -> . whileloop
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (15) returnstatement -> . RETURN
    (16) returnstatement -> . RETURN expr
    (22) assignstatement -> . assignable = expr
    (23) assignstatement -> . assignable ASSIGNPLUS expr
    (24) assignstatement -> . assignable ASSIGNMINUS expr
    (25) assignstatement -> . assignable ASSIGNTIMES expr
    (26) assignstatement -> . assignable ASSIGNDIVIDE expr
    (17) printstatement -> . PRINT printables
    (58) forloop -> . FOR ID = rangeoperator block
    (59) whileloop -> . WHILE ( expr ) block
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    {               shift and go to state 5
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 14
    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    RETURN          shift and go to state 24
    PRINT           shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 28
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 8
    block                          shift and go to state 124
    statement                      shift and go to state 118
    ifstatement                    shift and go to state 6
    loop                           shift and go to state 7
    returnstatement                shift and go to state 9
    assignstatement                shift and go to state 10
    printstatement                 shift and go to state 11
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assignable                     shift and go to state 18
    specialmatrixword              shift and go to state 22

state 117

    (54) ifstatement -> IF ( expr ) block .
    (55) ifstatement -> IF ( expr ) block . ELSE block

    {               reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    BREAK           reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    CONTINUE        reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    IF              reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    INTNUMBER       reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    FLOATNUMBER     reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    -               reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    (               reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    [               reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    RETURN          reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    PRINT           reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    FOR             reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    WHILE           reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    ID              reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    ZEROS           reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    ONES            reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    EYE             reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    $end            reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    }               reduce using rule 54 (ifstatement -> IF ( expr ) block .)
    ELSE            shift and go to state 125

  ! ELSE            [ reduce using rule 54 (ifstatement -> IF ( expr ) block .) ]


state 118

    (5) block -> statement .

    ELSE            reduce using rule 5 (block -> statement .)
    {               reduce using rule 5 (block -> statement .)
    BREAK           reduce using rule 5 (block -> statement .)
    CONTINUE        reduce using rule 5 (block -> statement .)
    IF              reduce using rule 5 (block -> statement .)
    INTNUMBER       reduce using rule 5 (block -> statement .)
    FLOATNUMBER     reduce using rule 5 (block -> statement .)
    -               reduce using rule 5 (block -> statement .)
    (               reduce using rule 5 (block -> statement .)
    [               reduce using rule 5 (block -> statement .)
    RETURN          reduce using rule 5 (block -> statement .)
    PRINT           reduce using rule 5 (block -> statement .)
    FOR             reduce using rule 5 (block -> statement .)
    WHILE           reduce using rule 5 (block -> statement .)
    ID              reduce using rule 5 (block -> statement .)
    ZEROS           reduce using rule 5 (block -> statement .)
    ONES            reduce using rule 5 (block -> statement .)
    EYE             reduce using rule 5 (block -> statement .)
    $end            reduce using rule 5 (block -> statement .)
    }               reduce using rule 5 (block -> statement .)


state 119

    (66) innerlist -> innerlist , expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ]               reduce using rule 66 (innerlist -> innerlist , expr .)
    ,               reduce using rule 66 (innerlist -> innerlist , expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 120

    (62) matrixinitializer -> vector , [ innerlist . ]
    (64) vector -> vector , [ innerlist . ]
    (66) innerlist -> innerlist . , expr

    ]               shift and go to state 126
    ,               shift and go to state 110


state 121

    (58) forloop -> FOR ID = rangeoperator block .

    {               reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    BREAK           reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    CONTINUE        reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    IF              reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    INTNUMBER       reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    FLOATNUMBER     reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    -               reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    (               reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    [               reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    RETURN          reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    PRINT           reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    FOR             reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    WHILE           reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    ID              reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    ZEROS           reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    ONES            reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    EYE             reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    $end            reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    }               reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)
    ELSE            reduce using rule 58 (forloop -> FOR ID = rangeoperator block .)


state 122

    (60) rangeoperator -> expr : . expr
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 127
    assignable                     shift and go to state 57
    specialmatrixword              shift and go to state 22

state 123

    (28) assignable -> ID [ expr , expr . ]
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

    ]               shift and go to state 128
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49


state 124

    (59) whileloop -> WHILE ( expr ) block .

    {               reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    BREAK           reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    CONTINUE        reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    IF              reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    INTNUMBER       reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    FLOATNUMBER     reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    -               reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    (               reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    [               reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    RETURN          reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    PRINT           reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    FOR             reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    WHILE           reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    ID              reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    ZEROS           reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    ONES            reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    EYE             reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    $end            reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    }               reduce using rule 59 (whileloop -> WHILE ( expr ) block .)
    ELSE            reduce using rule 59 (whileloop -> WHILE ( expr ) block .)


state 125

    (55) ifstatement -> IF ( expr ) block ELSE . block
    (5) block -> . statement
    (6) block -> . { morestatements }
    (7) statement -> . ifstatement
    (8) statement -> . loop
    (9) statement -> . expr ;
    (10) statement -> . returnstatement ;
    (11) statement -> . assignstatement ;
    (12) statement -> . printstatement ;
    (13) statement -> . BREAK ;
    (14) statement -> . CONTINUE ;
    (54) ifstatement -> . IF ( expr ) block
    (55) ifstatement -> . IF ( expr ) block ELSE block
    (56) loop -> . forloop
    (57) loop -> . whileloop
    (29) expr -> . assignable
    (30) expr -> . INTNUMBER
    (31) expr -> . FLOATNUMBER
    (32) expr -> . - expr
    (33) expr -> . expr '
    (34) expr -> . specialmatrixword ( expr )
    (35) expr -> . ( expr )
    (36) expr -> . [ matrixinitializer ]
    (37) expr -> . expr + expr
    (38) expr -> . expr - expr
    (39) expr -> . expr * expr
    (40) expr -> . expr / expr
    (41) expr -> . expr MPLUS expr
    (42) expr -> . expr MMINUS expr
    (43) expr -> . expr MTIMES expr
    (44) expr -> . expr MDIVIDE expr
    (45) expr -> . expr EQ expr
    (46) expr -> . expr NEQ expr
    (47) expr -> . expr > expr
    (48) expr -> . expr < expr
    (49) expr -> . expr LEQ expr
    (50) expr -> . expr GEQ expr
    (15) returnstatement -> . RETURN
    (16) returnstatement -> . RETURN expr
    (22) assignstatement -> . assignable = expr
    (23) assignstatement -> . assignable ASSIGNPLUS expr
    (24) assignstatement -> . assignable ASSIGNMINUS expr
    (25) assignstatement -> . assignable ASSIGNTIMES expr
    (26) assignstatement -> . assignable ASSIGNDIVIDE expr
    (17) printstatement -> . PRINT printables
    (58) forloop -> . FOR ID = rangeoperator block
    (59) whileloop -> . WHILE ( expr ) block
    (27) assignable -> . ID
    (28) assignable -> . ID [ expr , expr ]
    (51) specialmatrixword -> . ZEROS
    (52) specialmatrixword -> . ONES
    (53) specialmatrixword -> . EYE

    {               shift and go to state 5
    BREAK           shift and go to state 12
    CONTINUE        shift and go to state 13
    IF              shift and go to state 14
    INTNUMBER       shift and go to state 19
    FLOATNUMBER     shift and go to state 20
    -               shift and go to state 21
    (               shift and go to state 15
    [               shift and go to state 23
    RETURN          shift and go to state 24
    PRINT           shift and go to state 25
    FOR             shift and go to state 26
    WHILE           shift and go to state 28
    ID              shift and go to state 27
    ZEROS           shift and go to state 29
    ONES            shift and go to state 30
    EYE             shift and go to state 31

    expr                           shift and go to state 8
    block                          shift and go to state 129
    statement                      shift and go to state 118
    ifstatement                    shift and go to state 6
    loop                           shift and go to state 7
    returnstatement                shift and go to state 9
    assignstatement                shift and go to state 10
    printstatement                 shift and go to state 11
    forloop                        shift and go to state 16
    whileloop                      shift and go to state 17
    assignable                     shift and go to state 18
    specialmatrixword              shift and go to state 22

state 126

    (62) matrixinitializer -> vector , [ innerlist ] .
    (64) vector -> vector , [ innerlist ] .

    ]               reduce using rule 62 (matrixinitializer -> vector , [ innerlist ] .)
    ,               reduce using rule 64 (vector -> vector , [ innerlist ] .)


state 127

    (60) rangeoperator -> expr : expr .
    (33) expr -> expr . '
    (37) expr -> expr . + expr
    (38) expr -> expr . - expr
    (39) expr -> expr . * expr
    (40) expr -> expr . / expr
    (41) expr -> expr . MPLUS expr
    (42) expr -> expr . MMINUS expr
    (43) expr -> expr . MTIMES expr
    (44) expr -> expr . MDIVIDE expr
    (45) expr -> expr . EQ expr
    (46) expr -> expr . NEQ expr
    (47) expr -> expr . > expr
    (48) expr -> expr . < expr
    (49) expr -> expr . LEQ expr
    (50) expr -> expr . GEQ expr

  ! shift/reduce conflict for - resolved as shift
    {               reduce using rule 60 (rangeoperator -> expr : expr .)
    BREAK           reduce using rule 60 (rangeoperator -> expr : expr .)
    CONTINUE        reduce using rule 60 (rangeoperator -> expr : expr .)
    IF              reduce using rule 60 (rangeoperator -> expr : expr .)
    INTNUMBER       reduce using rule 60 (rangeoperator -> expr : expr .)
    FLOATNUMBER     reduce using rule 60 (rangeoperator -> expr : expr .)
    (               reduce using rule 60 (rangeoperator -> expr : expr .)
    [               reduce using rule 60 (rangeoperator -> expr : expr .)
    RETURN          reduce using rule 60 (rangeoperator -> expr : expr .)
    PRINT           reduce using rule 60 (rangeoperator -> expr : expr .)
    FOR             reduce using rule 60 (rangeoperator -> expr : expr .)
    WHILE           reduce using rule 60 (rangeoperator -> expr : expr .)
    ID              reduce using rule 60 (rangeoperator -> expr : expr .)
    ZEROS           reduce using rule 60 (rangeoperator -> expr : expr .)
    ONES            reduce using rule 60 (rangeoperator -> expr : expr .)
    EYE             reduce using rule 60 (rangeoperator -> expr : expr .)
    '               shift and go to state 35
    +               shift and go to state 36
    -               shift and go to state 37
    *               shift and go to state 38
    /               shift and go to state 39
    MPLUS           shift and go to state 40
    MMINUS          shift and go to state 41
    MTIMES          shift and go to state 42
    MDIVIDE         shift and go to state 43
    EQ              shift and go to state 44
    NEQ             shift and go to state 45
    >               shift and go to state 46
    <               shift and go to state 47
    LEQ             shift and go to state 48
    GEQ             shift and go to state 49

  ! -               [ reduce using rule 60 (rangeoperator -> expr : expr .) ]


state 128

    (28) assignable -> ID [ expr , expr ] .

    =               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    ASSIGNPLUS      reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    ASSIGNMINUS     reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    ASSIGNTIMES     reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    ASSIGNDIVIDE    reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    ;               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    '               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    +               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    -               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    *               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    /               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    MPLUS           reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    MMINUS          reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    MTIMES          reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    MDIVIDE         reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    EQ              reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    NEQ             reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    >               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    <               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    LEQ             reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    GEQ             reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    )               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    ,               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    ]               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    :               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    {               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    BREAK           reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    CONTINUE        reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    IF              reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    INTNUMBER       reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    FLOATNUMBER     reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    (               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    [               reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    RETURN          reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    PRINT           reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    FOR             reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    WHILE           reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    ID              reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    ZEROS           reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    ONES            reduce using rule 28 (assignable -> ID [ expr , expr ] .)
    EYE             reduce using rule 28 (assignable -> ID [ expr , expr ] .)


state 129

    (55) ifstatement -> IF ( expr ) block ELSE block .

    {               reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    BREAK           reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    CONTINUE        reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    IF              reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    INTNUMBER       reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    FLOATNUMBER     reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    -               reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    (               reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    [               reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    RETURN          reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    PRINT           reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    FOR             reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    WHILE           reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    ID              reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    ZEROS           reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    ONES            reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    EYE             reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    $end            reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    }               reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)
    ELSE            reduce using rule 55 (ifstatement -> IF ( expr ) block ELSE block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for [ in state 27 resolved as shift
WARNING: shift/reduce conflict for - in state 127 resolved as shift
