Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> <empty>
Rule 2     start -> morestatements
Rule 3     morestatements -> statement
Rule 4     morestatements -> statement morestatements
Rule 5     morestatements -> { morestatements }
Rule 6     statement -> ifstatement
Rule 7     statement -> loop
Rule 8     statement -> expr ;
Rule 9     statement -> returnstatement ;
Rule 10    statement -> assignstatement ;
Rule 11    statement -> printstatement ;
Rule 12    statement -> BREAK ;
Rule 13    statement -> CONTINUE ;
Rule 14    returnstatement -> RETURN
Rule 15    returnstatement -> RETURN expr
Rule 16    printstatement -> PRINT printables
Rule 17    printables -> printable
Rule 18    printables -> printables , printable
Rule 19    printable -> expr
Rule 20    printable -> STRING
Rule 21    assignstatement -> assignable = expr
Rule 22    assignstatement -> assignable ASSIGNPLUS expr
Rule 23    assignstatement -> assignable ASSIGNMINUS expr
Rule 24    assignstatement -> assignable ASSIGNTIMES expr
Rule 25    assignstatement -> assignable ASSIGNDIVIDE expr
Rule 26    assignable -> ID
Rule 27    assignable -> ID [ expr , expr ]
Rule 28    expr -> assignable
Rule 29    expr -> INTNUMBER
Rule 30    expr -> FLOATNUMBER
Rule 31    expr -> [ matrixinitializer ]
Rule 32    expr -> specialmatrixword ( expr )
Rule 33    expr -> - expr
Rule 34    expr -> expr '
Rule 35    expr -> ( expr )
Rule 36    expr -> expr + expr
Rule 37    expr -> expr - expr
Rule 38    expr -> expr * expr
Rule 39    expr -> expr / expr
Rule 40    expr -> expr MPLUS expr
Rule 41    expr -> expr MMINUS expr
Rule 42    expr -> expr MTIMES expr
Rule 43    expr -> expr MDIVIDE expr
Rule 44    expr -> expr EQ expr
Rule 45    expr -> expr NEQ expr
Rule 46    expr -> expr > expr
Rule 47    expr -> expr < expr
Rule 48    expr -> expr LEQ expr
Rule 49    expr -> expr GEQ expr
Rule 50    specialmatrixword -> ZEROS
Rule 51    specialmatrixword -> ONES
Rule 52    specialmatrixword -> EYE
Rule 53    ifstatement -> IF ( expr ) morestatements
Rule 54    ifstatement -> IF ( expr ) morestatements ELSE morestatements
Rule 55    loop -> forloop
Rule 56    loop -> whileloop
Rule 57    forloop -> FOR ID = rangeoperator morestatements
Rule 58    whileloop -> WHILE ( expr ) morestatements
Rule 59    rangeoperator -> expr : expr
Rule 60    matrixinitializer -> [ innerlist ]
Rule 61    matrixinitializer -> matrixinitializer , [ innerlist ]
Rule 62    innerlist -> expr
Rule 63    innerlist -> innerlist , expr

Terminals, with rules where they appear

'                    : 34
(                    : 32 35 53 54 58
)                    : 32 35 53 54 58
*                    : 38
+                    : 36
,                    : 18 27 61 63
-                    : 33 37
/                    : 39
:                    : 59
;                    : 8 9 10 11 12 13
<                    : 47
=                    : 21 57
>                    : 46
ASSIGNDIVIDE         : 25
ASSIGNMINUS          : 23
ASSIGNPLUS           : 22
ASSIGNTIMES          : 24
BREAK                : 12
CONTINUE             : 13
ELSE                 : 54
EQ                   : 44
EYE                  : 52
FLOATNUMBER          : 30
FOR                  : 57
GEQ                  : 49
ID                   : 26 27 57
IF                   : 53 54
INTNUMBER            : 29
LEQ                  : 48
MDIVIDE              : 43
MMINUS               : 41
MPLUS                : 40
MTIMES               : 42
NEQ                  : 45
ONES                 : 51
PRINT                : 16
RETURN               : 14 15
STRING               : 20
WHILE                : 58
ZEROS                : 50
[                    : 27 31 60 61
]                    : 27 31 60 61
error                : 
{                    : 5
}                    : 5

Nonterminals, with rules where they appear

assignable           : 21 22 23 24 25 28
assignstatement      : 10
expr                 : 8 15 19 21 22 23 24 25 27 27 32 33 34 35 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 53 54 58 59 59 62 63
forloop              : 55
ifstatement          : 6
innerlist            : 60 61 63
loop                 : 7
matrixinitializer    : 31 61
morestatements       : 2 4 5 53 54 54 57 58
printable            : 17 18
printables           : 16 18
printstatement       : 11
rangeoperator        : 57
returnstatement      : 9
specialmatrixword    : 32
start                : 0
statement            : 3 4
whileloop            : 56

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> .
    (2) start -> . morestatements
    (3) morestatements -> . statement
    (4) morestatements -> . statement morestatements
    (5) morestatements -> . { morestatements }
    (6) statement -> . ifstatement
    (7) statement -> . loop
    (8) statement -> . expr ;
    (9) statement -> . returnstatement ;
    (10) statement -> . assignstatement ;
    (11) statement -> . printstatement ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (53) ifstatement -> . IF ( expr ) morestatements
    (54) ifstatement -> . IF ( expr ) morestatements ELSE morestatements
    (55) loop -> . forloop
    (56) loop -> . whileloop
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (14) returnstatement -> . RETURN
    (15) returnstatement -> . RETURN expr
    (21) assignstatement -> . assignable = expr
    (22) assignstatement -> . assignable ASSIGNPLUS expr
    (23) assignstatement -> . assignable ASSIGNMINUS expr
    (24) assignstatement -> . assignable ASSIGNTIMES expr
    (25) assignstatement -> . assignable ASSIGNDIVIDE expr
    (16) printstatement -> . PRINT printables
    (57) forloop -> . FOR ID = rangeoperator morestatements
    (58) whileloop -> . WHILE ( expr ) morestatements
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    $end            reduce using rule 1 (start -> .)
    {               shift and go to state 4
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    IF              shift and go to state 13
    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    RETURN          shift and go to state 23
    PRINT           shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 27
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    start                          shift and go to state 1
    morestatements                 shift and go to state 2
    statement                      shift and go to state 3
    ifstatement                    shift and go to state 5
    loop                           shift and go to state 6
    expr                           shift and go to state 7
    returnstatement                shift and go to state 8
    assignstatement                shift and go to state 9
    printstatement                 shift and go to state 10
    forloop                        shift and go to state 15
    whileloop                      shift and go to state 16
    assignable                     shift and go to state 17
    specialmatrixword              shift and go to state 21

state 1

    (0) S' -> start .



state 2

    (2) start -> morestatements .

    $end            reduce using rule 2 (start -> morestatements .)


state 3

    (3) morestatements -> statement .
    (4) morestatements -> statement . morestatements
    (3) morestatements -> . statement
    (4) morestatements -> . statement morestatements
    (5) morestatements -> . { morestatements }
    (6) statement -> . ifstatement
    (7) statement -> . loop
    (8) statement -> . expr ;
    (9) statement -> . returnstatement ;
    (10) statement -> . assignstatement ;
    (11) statement -> . printstatement ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (53) ifstatement -> . IF ( expr ) morestatements
    (54) ifstatement -> . IF ( expr ) morestatements ELSE morestatements
    (55) loop -> . forloop
    (56) loop -> . whileloop
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (14) returnstatement -> . RETURN
    (15) returnstatement -> . RETURN expr
    (21) assignstatement -> . assignable = expr
    (22) assignstatement -> . assignable ASSIGNPLUS expr
    (23) assignstatement -> . assignable ASSIGNMINUS expr
    (24) assignstatement -> . assignable ASSIGNTIMES expr
    (25) assignstatement -> . assignable ASSIGNDIVIDE expr
    (16) printstatement -> . PRINT printables
    (57) forloop -> . FOR ID = rangeoperator morestatements
    (58) whileloop -> . WHILE ( expr ) morestatements
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for INTNUMBER resolved as shift
  ! shift/reduce conflict for FLOATNUMBER resolved as shift
  ! shift/reduce conflict for [ resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for ZEROS resolved as shift
  ! shift/reduce conflict for ONES resolved as shift
  ! shift/reduce conflict for EYE resolved as shift
    $end            reduce using rule 3 (morestatements -> statement .)
    }               reduce using rule 3 (morestatements -> statement .)
    ELSE            reduce using rule 3 (morestatements -> statement .)
    {               shift and go to state 4
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    IF              shift and go to state 13
    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    RETURN          shift and go to state 23
    PRINT           shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 27
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

  ! {               [ reduce using rule 3 (morestatements -> statement .) ]
  ! BREAK           [ reduce using rule 3 (morestatements -> statement .) ]
  ! CONTINUE        [ reduce using rule 3 (morestatements -> statement .) ]
  ! IF              [ reduce using rule 3 (morestatements -> statement .) ]
  ! INTNUMBER       [ reduce using rule 3 (morestatements -> statement .) ]
  ! FLOATNUMBER     [ reduce using rule 3 (morestatements -> statement .) ]
  ! [               [ reduce using rule 3 (morestatements -> statement .) ]
  ! -               [ reduce using rule 3 (morestatements -> statement .) ]
  ! (               [ reduce using rule 3 (morestatements -> statement .) ]
  ! RETURN          [ reduce using rule 3 (morestatements -> statement .) ]
  ! PRINT           [ reduce using rule 3 (morestatements -> statement .) ]
  ! FOR             [ reduce using rule 3 (morestatements -> statement .) ]
  ! WHILE           [ reduce using rule 3 (morestatements -> statement .) ]
  ! ID              [ reduce using rule 3 (morestatements -> statement .) ]
  ! ZEROS           [ reduce using rule 3 (morestatements -> statement .) ]
  ! ONES            [ reduce using rule 3 (morestatements -> statement .) ]
  ! EYE             [ reduce using rule 3 (morestatements -> statement .) ]

    statement                      shift and go to state 3
    morestatements                 shift and go to state 31
    ifstatement                    shift and go to state 5
    loop                           shift and go to state 6
    expr                           shift and go to state 7
    returnstatement                shift and go to state 8
    assignstatement                shift and go to state 9
    printstatement                 shift and go to state 10
    forloop                        shift and go to state 15
    whileloop                      shift and go to state 16
    assignable                     shift and go to state 17
    specialmatrixword              shift and go to state 21

state 4

    (5) morestatements -> { . morestatements }
    (3) morestatements -> . statement
    (4) morestatements -> . statement morestatements
    (5) morestatements -> . { morestatements }
    (6) statement -> . ifstatement
    (7) statement -> . loop
    (8) statement -> . expr ;
    (9) statement -> . returnstatement ;
    (10) statement -> . assignstatement ;
    (11) statement -> . printstatement ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (53) ifstatement -> . IF ( expr ) morestatements
    (54) ifstatement -> . IF ( expr ) morestatements ELSE morestatements
    (55) loop -> . forloop
    (56) loop -> . whileloop
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (14) returnstatement -> . RETURN
    (15) returnstatement -> . RETURN expr
    (21) assignstatement -> . assignable = expr
    (22) assignstatement -> . assignable ASSIGNPLUS expr
    (23) assignstatement -> . assignable ASSIGNMINUS expr
    (24) assignstatement -> . assignable ASSIGNTIMES expr
    (25) assignstatement -> . assignable ASSIGNDIVIDE expr
    (16) printstatement -> . PRINT printables
    (57) forloop -> . FOR ID = rangeoperator morestatements
    (58) whileloop -> . WHILE ( expr ) morestatements
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    {               shift and go to state 4
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    IF              shift and go to state 13
    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    RETURN          shift and go to state 23
    PRINT           shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 27
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    morestatements                 shift and go to state 32
    statement                      shift and go to state 3
    ifstatement                    shift and go to state 5
    loop                           shift and go to state 6
    expr                           shift and go to state 7
    returnstatement                shift and go to state 8
    assignstatement                shift and go to state 9
    printstatement                 shift and go to state 10
    forloop                        shift and go to state 15
    whileloop                      shift and go to state 16
    assignable                     shift and go to state 17
    specialmatrixword              shift and go to state 21

state 5

    (6) statement -> ifstatement .

    {               reduce using rule 6 (statement -> ifstatement .)
    BREAK           reduce using rule 6 (statement -> ifstatement .)
    CONTINUE        reduce using rule 6 (statement -> ifstatement .)
    IF              reduce using rule 6 (statement -> ifstatement .)
    INTNUMBER       reduce using rule 6 (statement -> ifstatement .)
    FLOATNUMBER     reduce using rule 6 (statement -> ifstatement .)
    [               reduce using rule 6 (statement -> ifstatement .)
    -               reduce using rule 6 (statement -> ifstatement .)
    (               reduce using rule 6 (statement -> ifstatement .)
    RETURN          reduce using rule 6 (statement -> ifstatement .)
    PRINT           reduce using rule 6 (statement -> ifstatement .)
    FOR             reduce using rule 6 (statement -> ifstatement .)
    WHILE           reduce using rule 6 (statement -> ifstatement .)
    ID              reduce using rule 6 (statement -> ifstatement .)
    ZEROS           reduce using rule 6 (statement -> ifstatement .)
    ONES            reduce using rule 6 (statement -> ifstatement .)
    EYE             reduce using rule 6 (statement -> ifstatement .)
    $end            reduce using rule 6 (statement -> ifstatement .)
    }               reduce using rule 6 (statement -> ifstatement .)
    ELSE            reduce using rule 6 (statement -> ifstatement .)


state 6

    (7) statement -> loop .

    {               reduce using rule 7 (statement -> loop .)
    BREAK           reduce using rule 7 (statement -> loop .)
    CONTINUE        reduce using rule 7 (statement -> loop .)
    IF              reduce using rule 7 (statement -> loop .)
    INTNUMBER       reduce using rule 7 (statement -> loop .)
    FLOATNUMBER     reduce using rule 7 (statement -> loop .)
    [               reduce using rule 7 (statement -> loop .)
    -               reduce using rule 7 (statement -> loop .)
    (               reduce using rule 7 (statement -> loop .)
    RETURN          reduce using rule 7 (statement -> loop .)
    PRINT           reduce using rule 7 (statement -> loop .)
    FOR             reduce using rule 7 (statement -> loop .)
    WHILE           reduce using rule 7 (statement -> loop .)
    ID              reduce using rule 7 (statement -> loop .)
    ZEROS           reduce using rule 7 (statement -> loop .)
    ONES            reduce using rule 7 (statement -> loop .)
    EYE             reduce using rule 7 (statement -> loop .)
    $end            reduce using rule 7 (statement -> loop .)
    }               reduce using rule 7 (statement -> loop .)
    ELSE            reduce using rule 7 (statement -> loop .)


state 7

    (8) statement -> expr . ;
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               shift and go to state 33
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 8

    (9) statement -> returnstatement . ;

    ;               shift and go to state 49


state 9

    (10) statement -> assignstatement . ;

    ;               shift and go to state 50


state 10

    (11) statement -> printstatement . ;

    ;               shift and go to state 51


state 11

    (12) statement -> BREAK . ;

    ;               shift and go to state 52


state 12

    (13) statement -> CONTINUE . ;

    ;               shift and go to state 53


state 13

    (53) ifstatement -> IF . ( expr ) morestatements
    (54) ifstatement -> IF . ( expr ) morestatements ELSE morestatements

    (               shift and go to state 54


state 14

    (35) expr -> ( . expr )
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 55
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 15

    (55) loop -> forloop .

    {               reduce using rule 55 (loop -> forloop .)
    BREAK           reduce using rule 55 (loop -> forloop .)
    CONTINUE        reduce using rule 55 (loop -> forloop .)
    IF              reduce using rule 55 (loop -> forloop .)
    INTNUMBER       reduce using rule 55 (loop -> forloop .)
    FLOATNUMBER     reduce using rule 55 (loop -> forloop .)
    [               reduce using rule 55 (loop -> forloop .)
    -               reduce using rule 55 (loop -> forloop .)
    (               reduce using rule 55 (loop -> forloop .)
    RETURN          reduce using rule 55 (loop -> forloop .)
    PRINT           reduce using rule 55 (loop -> forloop .)
    FOR             reduce using rule 55 (loop -> forloop .)
    WHILE           reduce using rule 55 (loop -> forloop .)
    ID              reduce using rule 55 (loop -> forloop .)
    ZEROS           reduce using rule 55 (loop -> forloop .)
    ONES            reduce using rule 55 (loop -> forloop .)
    EYE             reduce using rule 55 (loop -> forloop .)
    $end            reduce using rule 55 (loop -> forloop .)
    }               reduce using rule 55 (loop -> forloop .)
    ELSE            reduce using rule 55 (loop -> forloop .)


state 16

    (56) loop -> whileloop .

    {               reduce using rule 56 (loop -> whileloop .)
    BREAK           reduce using rule 56 (loop -> whileloop .)
    CONTINUE        reduce using rule 56 (loop -> whileloop .)
    IF              reduce using rule 56 (loop -> whileloop .)
    INTNUMBER       reduce using rule 56 (loop -> whileloop .)
    FLOATNUMBER     reduce using rule 56 (loop -> whileloop .)
    [               reduce using rule 56 (loop -> whileloop .)
    -               reduce using rule 56 (loop -> whileloop .)
    (               reduce using rule 56 (loop -> whileloop .)
    RETURN          reduce using rule 56 (loop -> whileloop .)
    PRINT           reduce using rule 56 (loop -> whileloop .)
    FOR             reduce using rule 56 (loop -> whileloop .)
    WHILE           reduce using rule 56 (loop -> whileloop .)
    ID              reduce using rule 56 (loop -> whileloop .)
    ZEROS           reduce using rule 56 (loop -> whileloop .)
    ONES            reduce using rule 56 (loop -> whileloop .)
    EYE             reduce using rule 56 (loop -> whileloop .)
    $end            reduce using rule 56 (loop -> whileloop .)
    }               reduce using rule 56 (loop -> whileloop .)
    ELSE            reduce using rule 56 (loop -> whileloop .)


state 17

    (28) expr -> assignable .
    (21) assignstatement -> assignable . = expr
    (22) assignstatement -> assignable . ASSIGNPLUS expr
    (23) assignstatement -> assignable . ASSIGNMINUS expr
    (24) assignstatement -> assignable . ASSIGNTIMES expr
    (25) assignstatement -> assignable . ASSIGNDIVIDE expr

    ;               reduce using rule 28 (expr -> assignable .)
    '               reduce using rule 28 (expr -> assignable .)
    +               reduce using rule 28 (expr -> assignable .)
    -               reduce using rule 28 (expr -> assignable .)
    *               reduce using rule 28 (expr -> assignable .)
    /               reduce using rule 28 (expr -> assignable .)
    MPLUS           reduce using rule 28 (expr -> assignable .)
    MMINUS          reduce using rule 28 (expr -> assignable .)
    MTIMES          reduce using rule 28 (expr -> assignable .)
    MDIVIDE         reduce using rule 28 (expr -> assignable .)
    EQ              reduce using rule 28 (expr -> assignable .)
    NEQ             reduce using rule 28 (expr -> assignable .)
    >               reduce using rule 28 (expr -> assignable .)
    <               reduce using rule 28 (expr -> assignable .)
    LEQ             reduce using rule 28 (expr -> assignable .)
    GEQ             reduce using rule 28 (expr -> assignable .)
    =               shift and go to state 57
    ASSIGNPLUS      shift and go to state 58
    ASSIGNMINUS     shift and go to state 59
    ASSIGNTIMES     shift and go to state 60
    ASSIGNDIVIDE    shift and go to state 61


state 18

    (29) expr -> INTNUMBER .

    ;               reduce using rule 29 (expr -> INTNUMBER .)
    '               reduce using rule 29 (expr -> INTNUMBER .)
    +               reduce using rule 29 (expr -> INTNUMBER .)
    -               reduce using rule 29 (expr -> INTNUMBER .)
    *               reduce using rule 29 (expr -> INTNUMBER .)
    /               reduce using rule 29 (expr -> INTNUMBER .)
    MPLUS           reduce using rule 29 (expr -> INTNUMBER .)
    MMINUS          reduce using rule 29 (expr -> INTNUMBER .)
    MTIMES          reduce using rule 29 (expr -> INTNUMBER .)
    MDIVIDE         reduce using rule 29 (expr -> INTNUMBER .)
    EQ              reduce using rule 29 (expr -> INTNUMBER .)
    NEQ             reduce using rule 29 (expr -> INTNUMBER .)
    >               reduce using rule 29 (expr -> INTNUMBER .)
    <               reduce using rule 29 (expr -> INTNUMBER .)
    LEQ             reduce using rule 29 (expr -> INTNUMBER .)
    GEQ             reduce using rule 29 (expr -> INTNUMBER .)
    )               reduce using rule 29 (expr -> INTNUMBER .)
    ,               reduce using rule 29 (expr -> INTNUMBER .)
    ]               reduce using rule 29 (expr -> INTNUMBER .)
    :               reduce using rule 29 (expr -> INTNUMBER .)
    {               reduce using rule 29 (expr -> INTNUMBER .)
    BREAK           reduce using rule 29 (expr -> INTNUMBER .)
    CONTINUE        reduce using rule 29 (expr -> INTNUMBER .)
    IF              reduce using rule 29 (expr -> INTNUMBER .)
    INTNUMBER       reduce using rule 29 (expr -> INTNUMBER .)
    FLOATNUMBER     reduce using rule 29 (expr -> INTNUMBER .)
    [               reduce using rule 29 (expr -> INTNUMBER .)
    (               reduce using rule 29 (expr -> INTNUMBER .)
    RETURN          reduce using rule 29 (expr -> INTNUMBER .)
    PRINT           reduce using rule 29 (expr -> INTNUMBER .)
    FOR             reduce using rule 29 (expr -> INTNUMBER .)
    WHILE           reduce using rule 29 (expr -> INTNUMBER .)
    ID              reduce using rule 29 (expr -> INTNUMBER .)
    ZEROS           reduce using rule 29 (expr -> INTNUMBER .)
    ONES            reduce using rule 29 (expr -> INTNUMBER .)
    EYE             reduce using rule 29 (expr -> INTNUMBER .)


state 19

    (30) expr -> FLOATNUMBER .

    ;               reduce using rule 30 (expr -> FLOATNUMBER .)
    '               reduce using rule 30 (expr -> FLOATNUMBER .)
    +               reduce using rule 30 (expr -> FLOATNUMBER .)
    -               reduce using rule 30 (expr -> FLOATNUMBER .)
    *               reduce using rule 30 (expr -> FLOATNUMBER .)
    /               reduce using rule 30 (expr -> FLOATNUMBER .)
    MPLUS           reduce using rule 30 (expr -> FLOATNUMBER .)
    MMINUS          reduce using rule 30 (expr -> FLOATNUMBER .)
    MTIMES          reduce using rule 30 (expr -> FLOATNUMBER .)
    MDIVIDE         reduce using rule 30 (expr -> FLOATNUMBER .)
    EQ              reduce using rule 30 (expr -> FLOATNUMBER .)
    NEQ             reduce using rule 30 (expr -> FLOATNUMBER .)
    >               reduce using rule 30 (expr -> FLOATNUMBER .)
    <               reduce using rule 30 (expr -> FLOATNUMBER .)
    LEQ             reduce using rule 30 (expr -> FLOATNUMBER .)
    GEQ             reduce using rule 30 (expr -> FLOATNUMBER .)
    )               reduce using rule 30 (expr -> FLOATNUMBER .)
    ,               reduce using rule 30 (expr -> FLOATNUMBER .)
    ]               reduce using rule 30 (expr -> FLOATNUMBER .)
    :               reduce using rule 30 (expr -> FLOATNUMBER .)
    {               reduce using rule 30 (expr -> FLOATNUMBER .)
    BREAK           reduce using rule 30 (expr -> FLOATNUMBER .)
    CONTINUE        reduce using rule 30 (expr -> FLOATNUMBER .)
    IF              reduce using rule 30 (expr -> FLOATNUMBER .)
    INTNUMBER       reduce using rule 30 (expr -> FLOATNUMBER .)
    FLOATNUMBER     reduce using rule 30 (expr -> FLOATNUMBER .)
    [               reduce using rule 30 (expr -> FLOATNUMBER .)
    (               reduce using rule 30 (expr -> FLOATNUMBER .)
    RETURN          reduce using rule 30 (expr -> FLOATNUMBER .)
    PRINT           reduce using rule 30 (expr -> FLOATNUMBER .)
    FOR             reduce using rule 30 (expr -> FLOATNUMBER .)
    WHILE           reduce using rule 30 (expr -> FLOATNUMBER .)
    ID              reduce using rule 30 (expr -> FLOATNUMBER .)
    ZEROS           reduce using rule 30 (expr -> FLOATNUMBER .)
    ONES            reduce using rule 30 (expr -> FLOATNUMBER .)
    EYE             reduce using rule 30 (expr -> FLOATNUMBER .)


state 20

    (31) expr -> [ . matrixinitializer ]
    (60) matrixinitializer -> . [ innerlist ]
    (61) matrixinitializer -> . matrixinitializer , [ innerlist ]

    [               shift and go to state 62

    matrixinitializer              shift and go to state 63

state 21

    (32) expr -> specialmatrixword . ( expr )

    (               shift and go to state 64


state 22

    (33) expr -> - . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 65
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 23

    (14) returnstatement -> RETURN .
    (15) returnstatement -> RETURN . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    ;               reduce using rule 14 (returnstatement -> RETURN .)
    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 66
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 24

    (16) printstatement -> PRINT . printables
    (17) printables -> . printable
    (18) printables -> . printables , printable
    (19) printable -> . expr
    (20) printable -> . STRING
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    STRING          shift and go to state 70
    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    printables                     shift and go to state 67
    printable                      shift and go to state 68
    expr                           shift and go to state 69
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 25

    (57) forloop -> FOR . ID = rangeoperator morestatements

    ID              shift and go to state 71


state 26

    (26) assignable -> ID .
    (27) assignable -> ID . [ expr , expr ]

  ! shift/reduce conflict for [ resolved as shift
    =               reduce using rule 26 (assignable -> ID .)
    ASSIGNPLUS      reduce using rule 26 (assignable -> ID .)
    ASSIGNMINUS     reduce using rule 26 (assignable -> ID .)
    ASSIGNTIMES     reduce using rule 26 (assignable -> ID .)
    ASSIGNDIVIDE    reduce using rule 26 (assignable -> ID .)
    ;               reduce using rule 26 (assignable -> ID .)
    '               reduce using rule 26 (assignable -> ID .)
    +               reduce using rule 26 (assignable -> ID .)
    -               reduce using rule 26 (assignable -> ID .)
    *               reduce using rule 26 (assignable -> ID .)
    /               reduce using rule 26 (assignable -> ID .)
    MPLUS           reduce using rule 26 (assignable -> ID .)
    MMINUS          reduce using rule 26 (assignable -> ID .)
    MTIMES          reduce using rule 26 (assignable -> ID .)
    MDIVIDE         reduce using rule 26 (assignable -> ID .)
    EQ              reduce using rule 26 (assignable -> ID .)
    NEQ             reduce using rule 26 (assignable -> ID .)
    >               reduce using rule 26 (assignable -> ID .)
    <               reduce using rule 26 (assignable -> ID .)
    LEQ             reduce using rule 26 (assignable -> ID .)
    GEQ             reduce using rule 26 (assignable -> ID .)
    )               reduce using rule 26 (assignable -> ID .)
    ,               reduce using rule 26 (assignable -> ID .)
    ]               reduce using rule 26 (assignable -> ID .)
    :               reduce using rule 26 (assignable -> ID .)
    {               reduce using rule 26 (assignable -> ID .)
    BREAK           reduce using rule 26 (assignable -> ID .)
    CONTINUE        reduce using rule 26 (assignable -> ID .)
    IF              reduce using rule 26 (assignable -> ID .)
    INTNUMBER       reduce using rule 26 (assignable -> ID .)
    FLOATNUMBER     reduce using rule 26 (assignable -> ID .)
    (               reduce using rule 26 (assignable -> ID .)
    RETURN          reduce using rule 26 (assignable -> ID .)
    PRINT           reduce using rule 26 (assignable -> ID .)
    FOR             reduce using rule 26 (assignable -> ID .)
    WHILE           reduce using rule 26 (assignable -> ID .)
    ID              reduce using rule 26 (assignable -> ID .)
    ZEROS           reduce using rule 26 (assignable -> ID .)
    ONES            reduce using rule 26 (assignable -> ID .)
    EYE             reduce using rule 26 (assignable -> ID .)
    [               shift and go to state 72

  ! [               [ reduce using rule 26 (assignable -> ID .) ]


state 27

    (58) whileloop -> WHILE . ( expr ) morestatements

    (               shift and go to state 73


state 28

    (50) specialmatrixword -> ZEROS .

    (               reduce using rule 50 (specialmatrixword -> ZEROS .)


state 29

    (51) specialmatrixword -> ONES .

    (               reduce using rule 51 (specialmatrixword -> ONES .)


state 30

    (52) specialmatrixword -> EYE .

    (               reduce using rule 52 (specialmatrixword -> EYE .)


state 31

    (4) morestatements -> statement morestatements .

    $end            reduce using rule 4 (morestatements -> statement morestatements .)
    }               reduce using rule 4 (morestatements -> statement morestatements .)
    ELSE            reduce using rule 4 (morestatements -> statement morestatements .)
    {               reduce using rule 4 (morestatements -> statement morestatements .)
    BREAK           reduce using rule 4 (morestatements -> statement morestatements .)
    CONTINUE        reduce using rule 4 (morestatements -> statement morestatements .)
    IF              reduce using rule 4 (morestatements -> statement morestatements .)
    INTNUMBER       reduce using rule 4 (morestatements -> statement morestatements .)
    FLOATNUMBER     reduce using rule 4 (morestatements -> statement morestatements .)
    [               reduce using rule 4 (morestatements -> statement morestatements .)
    -               reduce using rule 4 (morestatements -> statement morestatements .)
    (               reduce using rule 4 (morestatements -> statement morestatements .)
    RETURN          reduce using rule 4 (morestatements -> statement morestatements .)
    PRINT           reduce using rule 4 (morestatements -> statement morestatements .)
    FOR             reduce using rule 4 (morestatements -> statement morestatements .)
    WHILE           reduce using rule 4 (morestatements -> statement morestatements .)
    ID              reduce using rule 4 (morestatements -> statement morestatements .)
    ZEROS           reduce using rule 4 (morestatements -> statement morestatements .)
    ONES            reduce using rule 4 (morestatements -> statement morestatements .)
    EYE             reduce using rule 4 (morestatements -> statement morestatements .)


state 32

    (5) morestatements -> { morestatements . }

    }               shift and go to state 74


state 33

    (8) statement -> expr ; .

    {               reduce using rule 8 (statement -> expr ; .)
    BREAK           reduce using rule 8 (statement -> expr ; .)
    CONTINUE        reduce using rule 8 (statement -> expr ; .)
    IF              reduce using rule 8 (statement -> expr ; .)
    INTNUMBER       reduce using rule 8 (statement -> expr ; .)
    FLOATNUMBER     reduce using rule 8 (statement -> expr ; .)
    [               reduce using rule 8 (statement -> expr ; .)
    -               reduce using rule 8 (statement -> expr ; .)
    (               reduce using rule 8 (statement -> expr ; .)
    RETURN          reduce using rule 8 (statement -> expr ; .)
    PRINT           reduce using rule 8 (statement -> expr ; .)
    FOR             reduce using rule 8 (statement -> expr ; .)
    WHILE           reduce using rule 8 (statement -> expr ; .)
    ID              reduce using rule 8 (statement -> expr ; .)
    ZEROS           reduce using rule 8 (statement -> expr ; .)
    ONES            reduce using rule 8 (statement -> expr ; .)
    EYE             reduce using rule 8 (statement -> expr ; .)
    $end            reduce using rule 8 (statement -> expr ; .)
    }               reduce using rule 8 (statement -> expr ; .)
    ELSE            reduce using rule 8 (statement -> expr ; .)


state 34

    (34) expr -> expr ' .

    ;               reduce using rule 34 (expr -> expr ' .)
    '               reduce using rule 34 (expr -> expr ' .)
    +               reduce using rule 34 (expr -> expr ' .)
    -               reduce using rule 34 (expr -> expr ' .)
    *               reduce using rule 34 (expr -> expr ' .)
    /               reduce using rule 34 (expr -> expr ' .)
    MPLUS           reduce using rule 34 (expr -> expr ' .)
    MMINUS          reduce using rule 34 (expr -> expr ' .)
    MTIMES          reduce using rule 34 (expr -> expr ' .)
    MDIVIDE         reduce using rule 34 (expr -> expr ' .)
    EQ              reduce using rule 34 (expr -> expr ' .)
    NEQ             reduce using rule 34 (expr -> expr ' .)
    >               reduce using rule 34 (expr -> expr ' .)
    <               reduce using rule 34 (expr -> expr ' .)
    LEQ             reduce using rule 34 (expr -> expr ' .)
    GEQ             reduce using rule 34 (expr -> expr ' .)
    )               reduce using rule 34 (expr -> expr ' .)
    ,               reduce using rule 34 (expr -> expr ' .)
    ]               reduce using rule 34 (expr -> expr ' .)
    :               reduce using rule 34 (expr -> expr ' .)
    {               reduce using rule 34 (expr -> expr ' .)
    BREAK           reduce using rule 34 (expr -> expr ' .)
    CONTINUE        reduce using rule 34 (expr -> expr ' .)
    IF              reduce using rule 34 (expr -> expr ' .)
    INTNUMBER       reduce using rule 34 (expr -> expr ' .)
    FLOATNUMBER     reduce using rule 34 (expr -> expr ' .)
    [               reduce using rule 34 (expr -> expr ' .)
    (               reduce using rule 34 (expr -> expr ' .)
    RETURN          reduce using rule 34 (expr -> expr ' .)
    PRINT           reduce using rule 34 (expr -> expr ' .)
    FOR             reduce using rule 34 (expr -> expr ' .)
    WHILE           reduce using rule 34 (expr -> expr ' .)
    ID              reduce using rule 34 (expr -> expr ' .)
    ZEROS           reduce using rule 34 (expr -> expr ' .)
    ONES            reduce using rule 34 (expr -> expr ' .)
    EYE             reduce using rule 34 (expr -> expr ' .)


state 35

    (36) expr -> expr + . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 75
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 36

    (37) expr -> expr - . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 76
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 37

    (38) expr -> expr * . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 77
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 38

    (39) expr -> expr / . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 78
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 39

    (40) expr -> expr MPLUS . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 79
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 40

    (41) expr -> expr MMINUS . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 80
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 41

    (42) expr -> expr MTIMES . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 81
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 42

    (43) expr -> expr MDIVIDE . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 82
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 43

    (44) expr -> expr EQ . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 83
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 44

    (45) expr -> expr NEQ . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 84
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 45

    (46) expr -> expr > . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 85
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 46

    (47) expr -> expr < . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 86
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 47

    (48) expr -> expr LEQ . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 87
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 48

    (49) expr -> expr GEQ . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 88
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 49

    (9) statement -> returnstatement ; .

    {               reduce using rule 9 (statement -> returnstatement ; .)
    BREAK           reduce using rule 9 (statement -> returnstatement ; .)
    CONTINUE        reduce using rule 9 (statement -> returnstatement ; .)
    IF              reduce using rule 9 (statement -> returnstatement ; .)
    INTNUMBER       reduce using rule 9 (statement -> returnstatement ; .)
    FLOATNUMBER     reduce using rule 9 (statement -> returnstatement ; .)
    [               reduce using rule 9 (statement -> returnstatement ; .)
    -               reduce using rule 9 (statement -> returnstatement ; .)
    (               reduce using rule 9 (statement -> returnstatement ; .)
    RETURN          reduce using rule 9 (statement -> returnstatement ; .)
    PRINT           reduce using rule 9 (statement -> returnstatement ; .)
    FOR             reduce using rule 9 (statement -> returnstatement ; .)
    WHILE           reduce using rule 9 (statement -> returnstatement ; .)
    ID              reduce using rule 9 (statement -> returnstatement ; .)
    ZEROS           reduce using rule 9 (statement -> returnstatement ; .)
    ONES            reduce using rule 9 (statement -> returnstatement ; .)
    EYE             reduce using rule 9 (statement -> returnstatement ; .)
    $end            reduce using rule 9 (statement -> returnstatement ; .)
    }               reduce using rule 9 (statement -> returnstatement ; .)
    ELSE            reduce using rule 9 (statement -> returnstatement ; .)


state 50

    (10) statement -> assignstatement ; .

    {               reduce using rule 10 (statement -> assignstatement ; .)
    BREAK           reduce using rule 10 (statement -> assignstatement ; .)
    CONTINUE        reduce using rule 10 (statement -> assignstatement ; .)
    IF              reduce using rule 10 (statement -> assignstatement ; .)
    INTNUMBER       reduce using rule 10 (statement -> assignstatement ; .)
    FLOATNUMBER     reduce using rule 10 (statement -> assignstatement ; .)
    [               reduce using rule 10 (statement -> assignstatement ; .)
    -               reduce using rule 10 (statement -> assignstatement ; .)
    (               reduce using rule 10 (statement -> assignstatement ; .)
    RETURN          reduce using rule 10 (statement -> assignstatement ; .)
    PRINT           reduce using rule 10 (statement -> assignstatement ; .)
    FOR             reduce using rule 10 (statement -> assignstatement ; .)
    WHILE           reduce using rule 10 (statement -> assignstatement ; .)
    ID              reduce using rule 10 (statement -> assignstatement ; .)
    ZEROS           reduce using rule 10 (statement -> assignstatement ; .)
    ONES            reduce using rule 10 (statement -> assignstatement ; .)
    EYE             reduce using rule 10 (statement -> assignstatement ; .)
    $end            reduce using rule 10 (statement -> assignstatement ; .)
    }               reduce using rule 10 (statement -> assignstatement ; .)
    ELSE            reduce using rule 10 (statement -> assignstatement ; .)


state 51

    (11) statement -> printstatement ; .

    {               reduce using rule 11 (statement -> printstatement ; .)
    BREAK           reduce using rule 11 (statement -> printstatement ; .)
    CONTINUE        reduce using rule 11 (statement -> printstatement ; .)
    IF              reduce using rule 11 (statement -> printstatement ; .)
    INTNUMBER       reduce using rule 11 (statement -> printstatement ; .)
    FLOATNUMBER     reduce using rule 11 (statement -> printstatement ; .)
    [               reduce using rule 11 (statement -> printstatement ; .)
    -               reduce using rule 11 (statement -> printstatement ; .)
    (               reduce using rule 11 (statement -> printstatement ; .)
    RETURN          reduce using rule 11 (statement -> printstatement ; .)
    PRINT           reduce using rule 11 (statement -> printstatement ; .)
    FOR             reduce using rule 11 (statement -> printstatement ; .)
    WHILE           reduce using rule 11 (statement -> printstatement ; .)
    ID              reduce using rule 11 (statement -> printstatement ; .)
    ZEROS           reduce using rule 11 (statement -> printstatement ; .)
    ONES            reduce using rule 11 (statement -> printstatement ; .)
    EYE             reduce using rule 11 (statement -> printstatement ; .)
    $end            reduce using rule 11 (statement -> printstatement ; .)
    }               reduce using rule 11 (statement -> printstatement ; .)
    ELSE            reduce using rule 11 (statement -> printstatement ; .)


state 52

    (12) statement -> BREAK ; .

    {               reduce using rule 12 (statement -> BREAK ; .)
    BREAK           reduce using rule 12 (statement -> BREAK ; .)
    CONTINUE        reduce using rule 12 (statement -> BREAK ; .)
    IF              reduce using rule 12 (statement -> BREAK ; .)
    INTNUMBER       reduce using rule 12 (statement -> BREAK ; .)
    FLOATNUMBER     reduce using rule 12 (statement -> BREAK ; .)
    [               reduce using rule 12 (statement -> BREAK ; .)
    -               reduce using rule 12 (statement -> BREAK ; .)
    (               reduce using rule 12 (statement -> BREAK ; .)
    RETURN          reduce using rule 12 (statement -> BREAK ; .)
    PRINT           reduce using rule 12 (statement -> BREAK ; .)
    FOR             reduce using rule 12 (statement -> BREAK ; .)
    WHILE           reduce using rule 12 (statement -> BREAK ; .)
    ID              reduce using rule 12 (statement -> BREAK ; .)
    ZEROS           reduce using rule 12 (statement -> BREAK ; .)
    ONES            reduce using rule 12 (statement -> BREAK ; .)
    EYE             reduce using rule 12 (statement -> BREAK ; .)
    $end            reduce using rule 12 (statement -> BREAK ; .)
    }               reduce using rule 12 (statement -> BREAK ; .)
    ELSE            reduce using rule 12 (statement -> BREAK ; .)


state 53

    (13) statement -> CONTINUE ; .

    {               reduce using rule 13 (statement -> CONTINUE ; .)
    BREAK           reduce using rule 13 (statement -> CONTINUE ; .)
    CONTINUE        reduce using rule 13 (statement -> CONTINUE ; .)
    IF              reduce using rule 13 (statement -> CONTINUE ; .)
    INTNUMBER       reduce using rule 13 (statement -> CONTINUE ; .)
    FLOATNUMBER     reduce using rule 13 (statement -> CONTINUE ; .)
    [               reduce using rule 13 (statement -> CONTINUE ; .)
    -               reduce using rule 13 (statement -> CONTINUE ; .)
    (               reduce using rule 13 (statement -> CONTINUE ; .)
    RETURN          reduce using rule 13 (statement -> CONTINUE ; .)
    PRINT           reduce using rule 13 (statement -> CONTINUE ; .)
    FOR             reduce using rule 13 (statement -> CONTINUE ; .)
    WHILE           reduce using rule 13 (statement -> CONTINUE ; .)
    ID              reduce using rule 13 (statement -> CONTINUE ; .)
    ZEROS           reduce using rule 13 (statement -> CONTINUE ; .)
    ONES            reduce using rule 13 (statement -> CONTINUE ; .)
    EYE             reduce using rule 13 (statement -> CONTINUE ; .)
    $end            reduce using rule 13 (statement -> CONTINUE ; .)
    }               reduce using rule 13 (statement -> CONTINUE ; .)
    ELSE            reduce using rule 13 (statement -> CONTINUE ; .)


state 54

    (53) ifstatement -> IF ( . expr ) morestatements
    (54) ifstatement -> IF ( . expr ) morestatements ELSE morestatements
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 89
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 55

    (35) expr -> ( expr . )
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    )               shift and go to state 90
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 56

    (28) expr -> assignable .

    )               reduce using rule 28 (expr -> assignable .)
    '               reduce using rule 28 (expr -> assignable .)
    +               reduce using rule 28 (expr -> assignable .)
    -               reduce using rule 28 (expr -> assignable .)
    *               reduce using rule 28 (expr -> assignable .)
    /               reduce using rule 28 (expr -> assignable .)
    MPLUS           reduce using rule 28 (expr -> assignable .)
    MMINUS          reduce using rule 28 (expr -> assignable .)
    MTIMES          reduce using rule 28 (expr -> assignable .)
    MDIVIDE         reduce using rule 28 (expr -> assignable .)
    EQ              reduce using rule 28 (expr -> assignable .)
    NEQ             reduce using rule 28 (expr -> assignable .)
    >               reduce using rule 28 (expr -> assignable .)
    <               reduce using rule 28 (expr -> assignable .)
    LEQ             reduce using rule 28 (expr -> assignable .)
    GEQ             reduce using rule 28 (expr -> assignable .)
    ;               reduce using rule 28 (expr -> assignable .)
    ,               reduce using rule 28 (expr -> assignable .)
    ]               reduce using rule 28 (expr -> assignable .)
    :               reduce using rule 28 (expr -> assignable .)
    {               reduce using rule 28 (expr -> assignable .)
    BREAK           reduce using rule 28 (expr -> assignable .)
    CONTINUE        reduce using rule 28 (expr -> assignable .)
    IF              reduce using rule 28 (expr -> assignable .)
    INTNUMBER       reduce using rule 28 (expr -> assignable .)
    FLOATNUMBER     reduce using rule 28 (expr -> assignable .)
    [               reduce using rule 28 (expr -> assignable .)
    (               reduce using rule 28 (expr -> assignable .)
    RETURN          reduce using rule 28 (expr -> assignable .)
    PRINT           reduce using rule 28 (expr -> assignable .)
    FOR             reduce using rule 28 (expr -> assignable .)
    WHILE           reduce using rule 28 (expr -> assignable .)
    ID              reduce using rule 28 (expr -> assignable .)
    ZEROS           reduce using rule 28 (expr -> assignable .)
    ONES            reduce using rule 28 (expr -> assignable .)
    EYE             reduce using rule 28 (expr -> assignable .)


state 57

    (21) assignstatement -> assignable = . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    assignable                     shift and go to state 56
    expr                           shift and go to state 91
    specialmatrixword              shift and go to state 21

state 58

    (22) assignstatement -> assignable ASSIGNPLUS . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    assignable                     shift and go to state 56
    expr                           shift and go to state 92
    specialmatrixword              shift and go to state 21

state 59

    (23) assignstatement -> assignable ASSIGNMINUS . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    assignable                     shift and go to state 56
    expr                           shift and go to state 93
    specialmatrixword              shift and go to state 21

state 60

    (24) assignstatement -> assignable ASSIGNTIMES . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    assignable                     shift and go to state 56
    expr                           shift and go to state 94
    specialmatrixword              shift and go to state 21

state 61

    (25) assignstatement -> assignable ASSIGNDIVIDE . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    assignable                     shift and go to state 56
    expr                           shift and go to state 95
    specialmatrixword              shift and go to state 21

state 62

    (60) matrixinitializer -> [ . innerlist ]
    (62) innerlist -> . expr
    (63) innerlist -> . innerlist , expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    innerlist                      shift and go to state 96
    expr                           shift and go to state 97
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 63

    (31) expr -> [ matrixinitializer . ]
    (61) matrixinitializer -> matrixinitializer . , [ innerlist ]

    ]               shift and go to state 98
    ,               shift and go to state 99


state 64

    (32) expr -> specialmatrixword ( . expr )
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    specialmatrixword              shift and go to state 21
    expr                           shift and go to state 100
    assignable                     shift and go to state 56

state 65

    (33) expr -> - expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 33 (expr -> - expr .)
    '               reduce using rule 33 (expr -> - expr .)
    +               reduce using rule 33 (expr -> - expr .)
    -               reduce using rule 33 (expr -> - expr .)
    *               reduce using rule 33 (expr -> - expr .)
    /               reduce using rule 33 (expr -> - expr .)
    MPLUS           reduce using rule 33 (expr -> - expr .)
    MMINUS          reduce using rule 33 (expr -> - expr .)
    MTIMES          reduce using rule 33 (expr -> - expr .)
    MDIVIDE         reduce using rule 33 (expr -> - expr .)
    EQ              reduce using rule 33 (expr -> - expr .)
    NEQ             reduce using rule 33 (expr -> - expr .)
    >               reduce using rule 33 (expr -> - expr .)
    <               reduce using rule 33 (expr -> - expr .)
    LEQ             reduce using rule 33 (expr -> - expr .)
    GEQ             reduce using rule 33 (expr -> - expr .)
    )               reduce using rule 33 (expr -> - expr .)
    ,               reduce using rule 33 (expr -> - expr .)
    ]               reduce using rule 33 (expr -> - expr .)
    :               reduce using rule 33 (expr -> - expr .)
    {               reduce using rule 33 (expr -> - expr .)
    BREAK           reduce using rule 33 (expr -> - expr .)
    CONTINUE        reduce using rule 33 (expr -> - expr .)
    IF              reduce using rule 33 (expr -> - expr .)
    INTNUMBER       reduce using rule 33 (expr -> - expr .)
    FLOATNUMBER     reduce using rule 33 (expr -> - expr .)
    [               reduce using rule 33 (expr -> - expr .)
    (               reduce using rule 33 (expr -> - expr .)
    RETURN          reduce using rule 33 (expr -> - expr .)
    PRINT           reduce using rule 33 (expr -> - expr .)
    FOR             reduce using rule 33 (expr -> - expr .)
    WHILE           reduce using rule 33 (expr -> - expr .)
    ID              reduce using rule 33 (expr -> - expr .)
    ZEROS           reduce using rule 33 (expr -> - expr .)
    ONES            reduce using rule 33 (expr -> - expr .)
    EYE             reduce using rule 33 (expr -> - expr .)

  ! '               [ shift and go to state 34 ]
  ! +               [ shift and go to state 35 ]
  ! -               [ shift and go to state 36 ]
  ! *               [ shift and go to state 37 ]
  ! /               [ shift and go to state 38 ]
  ! MPLUS           [ shift and go to state 39 ]
  ! MMINUS          [ shift and go to state 40 ]
  ! MTIMES          [ shift and go to state 41 ]
  ! MDIVIDE         [ shift and go to state 42 ]
  ! EQ              [ shift and go to state 43 ]
  ! NEQ             [ shift and go to state 44 ]
  ! >               [ shift and go to state 45 ]
  ! <               [ shift and go to state 46 ]
  ! LEQ             [ shift and go to state 47 ]
  ! GEQ             [ shift and go to state 48 ]


state 66

    (15) returnstatement -> RETURN expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 15 (returnstatement -> RETURN expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 67

    (16) printstatement -> PRINT printables .
    (18) printables -> printables . , printable

    ;               reduce using rule 16 (printstatement -> PRINT printables .)
    ,               shift and go to state 101


state 68

    (17) printables -> printable .

    ,               reduce using rule 17 (printables -> printable .)
    ;               reduce using rule 17 (printables -> printable .)


state 69

    (19) printable -> expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ,               reduce using rule 19 (printable -> expr .)
    ;               reduce using rule 19 (printable -> expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 70

    (20) printable -> STRING .

    ,               reduce using rule 20 (printable -> STRING .)
    ;               reduce using rule 20 (printable -> STRING .)


state 71

    (57) forloop -> FOR ID . = rangeoperator morestatements

    =               shift and go to state 102


state 72

    (27) assignable -> ID [ . expr , expr ]
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 103
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 73

    (58) whileloop -> WHILE ( . expr ) morestatements
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 104
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 74

    (5) morestatements -> { morestatements } .

    $end            reduce using rule 5 (morestatements -> { morestatements } .)
    }               reduce using rule 5 (morestatements -> { morestatements } .)
    ELSE            reduce using rule 5 (morestatements -> { morestatements } .)
    {               reduce using rule 5 (morestatements -> { morestatements } .)
    BREAK           reduce using rule 5 (morestatements -> { morestatements } .)
    CONTINUE        reduce using rule 5 (morestatements -> { morestatements } .)
    IF              reduce using rule 5 (morestatements -> { morestatements } .)
    INTNUMBER       reduce using rule 5 (morestatements -> { morestatements } .)
    FLOATNUMBER     reduce using rule 5 (morestatements -> { morestatements } .)
    [               reduce using rule 5 (morestatements -> { morestatements } .)
    -               reduce using rule 5 (morestatements -> { morestatements } .)
    (               reduce using rule 5 (morestatements -> { morestatements } .)
    RETURN          reduce using rule 5 (morestatements -> { morestatements } .)
    PRINT           reduce using rule 5 (morestatements -> { morestatements } .)
    FOR             reduce using rule 5 (morestatements -> { morestatements } .)
    WHILE           reduce using rule 5 (morestatements -> { morestatements } .)
    ID              reduce using rule 5 (morestatements -> { morestatements } .)
    ZEROS           reduce using rule 5 (morestatements -> { morestatements } .)
    ONES            reduce using rule 5 (morestatements -> { morestatements } .)
    EYE             reduce using rule 5 (morestatements -> { morestatements } .)


state 75

    (36) expr -> expr + expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 36 (expr -> expr + expr .)
    +               reduce using rule 36 (expr -> expr + expr .)
    -               reduce using rule 36 (expr -> expr + expr .)
    MPLUS           reduce using rule 36 (expr -> expr + expr .)
    MMINUS          reduce using rule 36 (expr -> expr + expr .)
    MTIMES          reduce using rule 36 (expr -> expr + expr .)
    MDIVIDE         reduce using rule 36 (expr -> expr + expr .)
    EQ              reduce using rule 36 (expr -> expr + expr .)
    NEQ             reduce using rule 36 (expr -> expr + expr .)
    >               reduce using rule 36 (expr -> expr + expr .)
    <               reduce using rule 36 (expr -> expr + expr .)
    LEQ             reduce using rule 36 (expr -> expr + expr .)
    GEQ             reduce using rule 36 (expr -> expr + expr .)
    )               reduce using rule 36 (expr -> expr + expr .)
    ,               reduce using rule 36 (expr -> expr + expr .)
    ]               reduce using rule 36 (expr -> expr + expr .)
    :               reduce using rule 36 (expr -> expr + expr .)
    {               reduce using rule 36 (expr -> expr + expr .)
    BREAK           reduce using rule 36 (expr -> expr + expr .)
    CONTINUE        reduce using rule 36 (expr -> expr + expr .)
    IF              reduce using rule 36 (expr -> expr + expr .)
    INTNUMBER       reduce using rule 36 (expr -> expr + expr .)
    FLOATNUMBER     reduce using rule 36 (expr -> expr + expr .)
    [               reduce using rule 36 (expr -> expr + expr .)
    (               reduce using rule 36 (expr -> expr + expr .)
    RETURN          reduce using rule 36 (expr -> expr + expr .)
    PRINT           reduce using rule 36 (expr -> expr + expr .)
    FOR             reduce using rule 36 (expr -> expr + expr .)
    WHILE           reduce using rule 36 (expr -> expr + expr .)
    ID              reduce using rule 36 (expr -> expr + expr .)
    ZEROS           reduce using rule 36 (expr -> expr + expr .)
    ONES            reduce using rule 36 (expr -> expr + expr .)
    EYE             reduce using rule 36 (expr -> expr + expr .)
    '               shift and go to state 34
    *               shift and go to state 37
    /               shift and go to state 38

  ! '               [ reduce using rule 36 (expr -> expr + expr .) ]
  ! *               [ reduce using rule 36 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 36 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 35 ]
  ! -               [ shift and go to state 36 ]
  ! MPLUS           [ shift and go to state 39 ]
  ! MMINUS          [ shift and go to state 40 ]
  ! MTIMES          [ shift and go to state 41 ]
  ! MDIVIDE         [ shift and go to state 42 ]
  ! EQ              [ shift and go to state 43 ]
  ! NEQ             [ shift and go to state 44 ]
  ! >               [ shift and go to state 45 ]
  ! <               [ shift and go to state 46 ]
  ! LEQ             [ shift and go to state 47 ]
  ! GEQ             [ shift and go to state 48 ]


state 76

    (37) expr -> expr - expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 37 (expr -> expr - expr .)
    +               reduce using rule 37 (expr -> expr - expr .)
    -               reduce using rule 37 (expr -> expr - expr .)
    MPLUS           reduce using rule 37 (expr -> expr - expr .)
    MMINUS          reduce using rule 37 (expr -> expr - expr .)
    MTIMES          reduce using rule 37 (expr -> expr - expr .)
    MDIVIDE         reduce using rule 37 (expr -> expr - expr .)
    EQ              reduce using rule 37 (expr -> expr - expr .)
    NEQ             reduce using rule 37 (expr -> expr - expr .)
    >               reduce using rule 37 (expr -> expr - expr .)
    <               reduce using rule 37 (expr -> expr - expr .)
    LEQ             reduce using rule 37 (expr -> expr - expr .)
    GEQ             reduce using rule 37 (expr -> expr - expr .)
    )               reduce using rule 37 (expr -> expr - expr .)
    ,               reduce using rule 37 (expr -> expr - expr .)
    ]               reduce using rule 37 (expr -> expr - expr .)
    :               reduce using rule 37 (expr -> expr - expr .)
    {               reduce using rule 37 (expr -> expr - expr .)
    BREAK           reduce using rule 37 (expr -> expr - expr .)
    CONTINUE        reduce using rule 37 (expr -> expr - expr .)
    IF              reduce using rule 37 (expr -> expr - expr .)
    INTNUMBER       reduce using rule 37 (expr -> expr - expr .)
    FLOATNUMBER     reduce using rule 37 (expr -> expr - expr .)
    [               reduce using rule 37 (expr -> expr - expr .)
    (               reduce using rule 37 (expr -> expr - expr .)
    RETURN          reduce using rule 37 (expr -> expr - expr .)
    PRINT           reduce using rule 37 (expr -> expr - expr .)
    FOR             reduce using rule 37 (expr -> expr - expr .)
    WHILE           reduce using rule 37 (expr -> expr - expr .)
    ID              reduce using rule 37 (expr -> expr - expr .)
    ZEROS           reduce using rule 37 (expr -> expr - expr .)
    ONES            reduce using rule 37 (expr -> expr - expr .)
    EYE             reduce using rule 37 (expr -> expr - expr .)
    '               shift and go to state 34
    *               shift and go to state 37
    /               shift and go to state 38

  ! '               [ reduce using rule 37 (expr -> expr - expr .) ]
  ! *               [ reduce using rule 37 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 37 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 35 ]
  ! -               [ shift and go to state 36 ]
  ! MPLUS           [ shift and go to state 39 ]
  ! MMINUS          [ shift and go to state 40 ]
  ! MTIMES          [ shift and go to state 41 ]
  ! MDIVIDE         [ shift and go to state 42 ]
  ! EQ              [ shift and go to state 43 ]
  ! NEQ             [ shift and go to state 44 ]
  ! >               [ shift and go to state 45 ]
  ! <               [ shift and go to state 46 ]
  ! LEQ             [ shift and go to state 47 ]
  ! GEQ             [ shift and go to state 48 ]


state 77

    (38) expr -> expr * expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 38 (expr -> expr * expr .)
    +               reduce using rule 38 (expr -> expr * expr .)
    -               reduce using rule 38 (expr -> expr * expr .)
    *               reduce using rule 38 (expr -> expr * expr .)
    /               reduce using rule 38 (expr -> expr * expr .)
    MPLUS           reduce using rule 38 (expr -> expr * expr .)
    MMINUS          reduce using rule 38 (expr -> expr * expr .)
    MTIMES          reduce using rule 38 (expr -> expr * expr .)
    MDIVIDE         reduce using rule 38 (expr -> expr * expr .)
    EQ              reduce using rule 38 (expr -> expr * expr .)
    NEQ             reduce using rule 38 (expr -> expr * expr .)
    >               reduce using rule 38 (expr -> expr * expr .)
    <               reduce using rule 38 (expr -> expr * expr .)
    LEQ             reduce using rule 38 (expr -> expr * expr .)
    GEQ             reduce using rule 38 (expr -> expr * expr .)
    )               reduce using rule 38 (expr -> expr * expr .)
    ,               reduce using rule 38 (expr -> expr * expr .)
    ]               reduce using rule 38 (expr -> expr * expr .)
    :               reduce using rule 38 (expr -> expr * expr .)
    {               reduce using rule 38 (expr -> expr * expr .)
    BREAK           reduce using rule 38 (expr -> expr * expr .)
    CONTINUE        reduce using rule 38 (expr -> expr * expr .)
    IF              reduce using rule 38 (expr -> expr * expr .)
    INTNUMBER       reduce using rule 38 (expr -> expr * expr .)
    FLOATNUMBER     reduce using rule 38 (expr -> expr * expr .)
    [               reduce using rule 38 (expr -> expr * expr .)
    (               reduce using rule 38 (expr -> expr * expr .)
    RETURN          reduce using rule 38 (expr -> expr * expr .)
    PRINT           reduce using rule 38 (expr -> expr * expr .)
    FOR             reduce using rule 38 (expr -> expr * expr .)
    WHILE           reduce using rule 38 (expr -> expr * expr .)
    ID              reduce using rule 38 (expr -> expr * expr .)
    ZEROS           reduce using rule 38 (expr -> expr * expr .)
    ONES            reduce using rule 38 (expr -> expr * expr .)
    EYE             reduce using rule 38 (expr -> expr * expr .)
    '               shift and go to state 34

  ! '               [ reduce using rule 38 (expr -> expr * expr .) ]
  ! +               [ shift and go to state 35 ]
  ! -               [ shift and go to state 36 ]
  ! *               [ shift and go to state 37 ]
  ! /               [ shift and go to state 38 ]
  ! MPLUS           [ shift and go to state 39 ]
  ! MMINUS          [ shift and go to state 40 ]
  ! MTIMES          [ shift and go to state 41 ]
  ! MDIVIDE         [ shift and go to state 42 ]
  ! EQ              [ shift and go to state 43 ]
  ! NEQ             [ shift and go to state 44 ]
  ! >               [ shift and go to state 45 ]
  ! <               [ shift and go to state 46 ]
  ! LEQ             [ shift and go to state 47 ]
  ! GEQ             [ shift and go to state 48 ]


state 78

    (39) expr -> expr / expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 39 (expr -> expr / expr .)
    +               reduce using rule 39 (expr -> expr / expr .)
    -               reduce using rule 39 (expr -> expr / expr .)
    *               reduce using rule 39 (expr -> expr / expr .)
    /               reduce using rule 39 (expr -> expr / expr .)
    MPLUS           reduce using rule 39 (expr -> expr / expr .)
    MMINUS          reduce using rule 39 (expr -> expr / expr .)
    MTIMES          reduce using rule 39 (expr -> expr / expr .)
    MDIVIDE         reduce using rule 39 (expr -> expr / expr .)
    EQ              reduce using rule 39 (expr -> expr / expr .)
    NEQ             reduce using rule 39 (expr -> expr / expr .)
    >               reduce using rule 39 (expr -> expr / expr .)
    <               reduce using rule 39 (expr -> expr / expr .)
    LEQ             reduce using rule 39 (expr -> expr / expr .)
    GEQ             reduce using rule 39 (expr -> expr / expr .)
    )               reduce using rule 39 (expr -> expr / expr .)
    ,               reduce using rule 39 (expr -> expr / expr .)
    ]               reduce using rule 39 (expr -> expr / expr .)
    :               reduce using rule 39 (expr -> expr / expr .)
    {               reduce using rule 39 (expr -> expr / expr .)
    BREAK           reduce using rule 39 (expr -> expr / expr .)
    CONTINUE        reduce using rule 39 (expr -> expr / expr .)
    IF              reduce using rule 39 (expr -> expr / expr .)
    INTNUMBER       reduce using rule 39 (expr -> expr / expr .)
    FLOATNUMBER     reduce using rule 39 (expr -> expr / expr .)
    [               reduce using rule 39 (expr -> expr / expr .)
    (               reduce using rule 39 (expr -> expr / expr .)
    RETURN          reduce using rule 39 (expr -> expr / expr .)
    PRINT           reduce using rule 39 (expr -> expr / expr .)
    FOR             reduce using rule 39 (expr -> expr / expr .)
    WHILE           reduce using rule 39 (expr -> expr / expr .)
    ID              reduce using rule 39 (expr -> expr / expr .)
    ZEROS           reduce using rule 39 (expr -> expr / expr .)
    ONES            reduce using rule 39 (expr -> expr / expr .)
    EYE             reduce using rule 39 (expr -> expr / expr .)
    '               shift and go to state 34

  ! '               [ reduce using rule 39 (expr -> expr / expr .) ]
  ! +               [ shift and go to state 35 ]
  ! -               [ shift and go to state 36 ]
  ! *               [ shift and go to state 37 ]
  ! /               [ shift and go to state 38 ]
  ! MPLUS           [ shift and go to state 39 ]
  ! MMINUS          [ shift and go to state 40 ]
  ! MTIMES          [ shift and go to state 41 ]
  ! MDIVIDE         [ shift and go to state 42 ]
  ! EQ              [ shift and go to state 43 ]
  ! NEQ             [ shift and go to state 44 ]
  ! >               [ shift and go to state 45 ]
  ! <               [ shift and go to state 46 ]
  ! LEQ             [ shift and go to state 47 ]
  ! GEQ             [ shift and go to state 48 ]


state 79

    (40) expr -> expr MPLUS expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

  ! shift/reduce conflict for ' resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for MPLUS resolved as shift
  ! shift/reduce conflict for MMINUS resolved as shift
  ! shift/reduce conflict for MTIMES resolved as shift
  ! shift/reduce conflict for MDIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
    ;               reduce using rule 40 (expr -> expr MPLUS expr .)
    )               reduce using rule 40 (expr -> expr MPLUS expr .)
    ,               reduce using rule 40 (expr -> expr MPLUS expr .)
    ]               reduce using rule 40 (expr -> expr MPLUS expr .)
    :               reduce using rule 40 (expr -> expr MPLUS expr .)
    {               reduce using rule 40 (expr -> expr MPLUS expr .)
    BREAK           reduce using rule 40 (expr -> expr MPLUS expr .)
    CONTINUE        reduce using rule 40 (expr -> expr MPLUS expr .)
    IF              reduce using rule 40 (expr -> expr MPLUS expr .)
    INTNUMBER       reduce using rule 40 (expr -> expr MPLUS expr .)
    FLOATNUMBER     reduce using rule 40 (expr -> expr MPLUS expr .)
    [               reduce using rule 40 (expr -> expr MPLUS expr .)
    (               reduce using rule 40 (expr -> expr MPLUS expr .)
    RETURN          reduce using rule 40 (expr -> expr MPLUS expr .)
    PRINT           reduce using rule 40 (expr -> expr MPLUS expr .)
    FOR             reduce using rule 40 (expr -> expr MPLUS expr .)
    WHILE           reduce using rule 40 (expr -> expr MPLUS expr .)
    ID              reduce using rule 40 (expr -> expr MPLUS expr .)
    ZEROS           reduce using rule 40 (expr -> expr MPLUS expr .)
    ONES            reduce using rule 40 (expr -> expr MPLUS expr .)
    EYE             reduce using rule 40 (expr -> expr MPLUS expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48

  ! '               [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! +               [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! -               [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! *               [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! /               [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! MPLUS           [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! MMINUS          [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! MTIMES          [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! MDIVIDE         [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! EQ              [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! NEQ             [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! >               [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! <               [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! LEQ             [ reduce using rule 40 (expr -> expr MPLUS expr .) ]
  ! GEQ             [ reduce using rule 40 (expr -> expr MPLUS expr .) ]


state 80

    (41) expr -> expr MMINUS expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

  ! shift/reduce conflict for ' resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for MPLUS resolved as shift
  ! shift/reduce conflict for MMINUS resolved as shift
  ! shift/reduce conflict for MTIMES resolved as shift
  ! shift/reduce conflict for MDIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
    ;               reduce using rule 41 (expr -> expr MMINUS expr .)
    )               reduce using rule 41 (expr -> expr MMINUS expr .)
    ,               reduce using rule 41 (expr -> expr MMINUS expr .)
    ]               reduce using rule 41 (expr -> expr MMINUS expr .)
    :               reduce using rule 41 (expr -> expr MMINUS expr .)
    {               reduce using rule 41 (expr -> expr MMINUS expr .)
    BREAK           reduce using rule 41 (expr -> expr MMINUS expr .)
    CONTINUE        reduce using rule 41 (expr -> expr MMINUS expr .)
    IF              reduce using rule 41 (expr -> expr MMINUS expr .)
    INTNUMBER       reduce using rule 41 (expr -> expr MMINUS expr .)
    FLOATNUMBER     reduce using rule 41 (expr -> expr MMINUS expr .)
    [               reduce using rule 41 (expr -> expr MMINUS expr .)
    (               reduce using rule 41 (expr -> expr MMINUS expr .)
    RETURN          reduce using rule 41 (expr -> expr MMINUS expr .)
    PRINT           reduce using rule 41 (expr -> expr MMINUS expr .)
    FOR             reduce using rule 41 (expr -> expr MMINUS expr .)
    WHILE           reduce using rule 41 (expr -> expr MMINUS expr .)
    ID              reduce using rule 41 (expr -> expr MMINUS expr .)
    ZEROS           reduce using rule 41 (expr -> expr MMINUS expr .)
    ONES            reduce using rule 41 (expr -> expr MMINUS expr .)
    EYE             reduce using rule 41 (expr -> expr MMINUS expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48

  ! '               [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! +               [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! -               [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! *               [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! /               [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! MPLUS           [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! MMINUS          [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! MTIMES          [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! MDIVIDE         [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! EQ              [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! NEQ             [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! >               [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! <               [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! LEQ             [ reduce using rule 41 (expr -> expr MMINUS expr .) ]
  ! GEQ             [ reduce using rule 41 (expr -> expr MMINUS expr .) ]


state 81

    (42) expr -> expr MTIMES expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

  ! shift/reduce conflict for ' resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for MPLUS resolved as shift
  ! shift/reduce conflict for MMINUS resolved as shift
  ! shift/reduce conflict for MTIMES resolved as shift
  ! shift/reduce conflict for MDIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
    ;               reduce using rule 42 (expr -> expr MTIMES expr .)
    )               reduce using rule 42 (expr -> expr MTIMES expr .)
    ,               reduce using rule 42 (expr -> expr MTIMES expr .)
    ]               reduce using rule 42 (expr -> expr MTIMES expr .)
    :               reduce using rule 42 (expr -> expr MTIMES expr .)
    {               reduce using rule 42 (expr -> expr MTIMES expr .)
    BREAK           reduce using rule 42 (expr -> expr MTIMES expr .)
    CONTINUE        reduce using rule 42 (expr -> expr MTIMES expr .)
    IF              reduce using rule 42 (expr -> expr MTIMES expr .)
    INTNUMBER       reduce using rule 42 (expr -> expr MTIMES expr .)
    FLOATNUMBER     reduce using rule 42 (expr -> expr MTIMES expr .)
    [               reduce using rule 42 (expr -> expr MTIMES expr .)
    (               reduce using rule 42 (expr -> expr MTIMES expr .)
    RETURN          reduce using rule 42 (expr -> expr MTIMES expr .)
    PRINT           reduce using rule 42 (expr -> expr MTIMES expr .)
    FOR             reduce using rule 42 (expr -> expr MTIMES expr .)
    WHILE           reduce using rule 42 (expr -> expr MTIMES expr .)
    ID              reduce using rule 42 (expr -> expr MTIMES expr .)
    ZEROS           reduce using rule 42 (expr -> expr MTIMES expr .)
    ONES            reduce using rule 42 (expr -> expr MTIMES expr .)
    EYE             reduce using rule 42 (expr -> expr MTIMES expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48

  ! '               [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! +               [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! -               [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! *               [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! /               [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! MPLUS           [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! MMINUS          [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! MTIMES          [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! MDIVIDE         [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! EQ              [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! NEQ             [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! >               [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! <               [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! LEQ             [ reduce using rule 42 (expr -> expr MTIMES expr .) ]
  ! GEQ             [ reduce using rule 42 (expr -> expr MTIMES expr .) ]


state 82

    (43) expr -> expr MDIVIDE expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

  ! shift/reduce conflict for ' resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for MPLUS resolved as shift
  ! shift/reduce conflict for MMINUS resolved as shift
  ! shift/reduce conflict for MTIMES resolved as shift
  ! shift/reduce conflict for MDIVIDE resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
  ! shift/reduce conflict for > resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LEQ resolved as shift
  ! shift/reduce conflict for GEQ resolved as shift
    ;               reduce using rule 43 (expr -> expr MDIVIDE expr .)
    )               reduce using rule 43 (expr -> expr MDIVIDE expr .)
    ,               reduce using rule 43 (expr -> expr MDIVIDE expr .)
    ]               reduce using rule 43 (expr -> expr MDIVIDE expr .)
    :               reduce using rule 43 (expr -> expr MDIVIDE expr .)
    {               reduce using rule 43 (expr -> expr MDIVIDE expr .)
    BREAK           reduce using rule 43 (expr -> expr MDIVIDE expr .)
    CONTINUE        reduce using rule 43 (expr -> expr MDIVIDE expr .)
    IF              reduce using rule 43 (expr -> expr MDIVIDE expr .)
    INTNUMBER       reduce using rule 43 (expr -> expr MDIVIDE expr .)
    FLOATNUMBER     reduce using rule 43 (expr -> expr MDIVIDE expr .)
    [               reduce using rule 43 (expr -> expr MDIVIDE expr .)
    (               reduce using rule 43 (expr -> expr MDIVIDE expr .)
    RETURN          reduce using rule 43 (expr -> expr MDIVIDE expr .)
    PRINT           reduce using rule 43 (expr -> expr MDIVIDE expr .)
    FOR             reduce using rule 43 (expr -> expr MDIVIDE expr .)
    WHILE           reduce using rule 43 (expr -> expr MDIVIDE expr .)
    ID              reduce using rule 43 (expr -> expr MDIVIDE expr .)
    ZEROS           reduce using rule 43 (expr -> expr MDIVIDE expr .)
    ONES            reduce using rule 43 (expr -> expr MDIVIDE expr .)
    EYE             reduce using rule 43 (expr -> expr MDIVIDE expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48

  ! '               [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! +               [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! -               [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! *               [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! /               [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! MPLUS           [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! MMINUS          [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! MTIMES          [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! MDIVIDE         [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! EQ              [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! NEQ             [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! >               [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! <               [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! LEQ             [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]
  ! GEQ             [ reduce using rule 43 (expr -> expr MDIVIDE expr .) ]


state 83

    (44) expr -> expr EQ expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 44 (expr -> expr EQ expr .)
    MPLUS           reduce using rule 44 (expr -> expr EQ expr .)
    MMINUS          reduce using rule 44 (expr -> expr EQ expr .)
    MTIMES          reduce using rule 44 (expr -> expr EQ expr .)
    MDIVIDE         reduce using rule 44 (expr -> expr EQ expr .)
    EQ              reduce using rule 44 (expr -> expr EQ expr .)
    NEQ             reduce using rule 44 (expr -> expr EQ expr .)
    >               reduce using rule 44 (expr -> expr EQ expr .)
    <               reduce using rule 44 (expr -> expr EQ expr .)
    LEQ             reduce using rule 44 (expr -> expr EQ expr .)
    GEQ             reduce using rule 44 (expr -> expr EQ expr .)
    )               reduce using rule 44 (expr -> expr EQ expr .)
    ,               reduce using rule 44 (expr -> expr EQ expr .)
    ]               reduce using rule 44 (expr -> expr EQ expr .)
    :               reduce using rule 44 (expr -> expr EQ expr .)
    {               reduce using rule 44 (expr -> expr EQ expr .)
    BREAK           reduce using rule 44 (expr -> expr EQ expr .)
    CONTINUE        reduce using rule 44 (expr -> expr EQ expr .)
    IF              reduce using rule 44 (expr -> expr EQ expr .)
    INTNUMBER       reduce using rule 44 (expr -> expr EQ expr .)
    FLOATNUMBER     reduce using rule 44 (expr -> expr EQ expr .)
    [               reduce using rule 44 (expr -> expr EQ expr .)
    (               reduce using rule 44 (expr -> expr EQ expr .)
    RETURN          reduce using rule 44 (expr -> expr EQ expr .)
    PRINT           reduce using rule 44 (expr -> expr EQ expr .)
    FOR             reduce using rule 44 (expr -> expr EQ expr .)
    WHILE           reduce using rule 44 (expr -> expr EQ expr .)
    ID              reduce using rule 44 (expr -> expr EQ expr .)
    ZEROS           reduce using rule 44 (expr -> expr EQ expr .)
    ONES            reduce using rule 44 (expr -> expr EQ expr .)
    EYE             reduce using rule 44 (expr -> expr EQ expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38

  ! '               [ reduce using rule 44 (expr -> expr EQ expr .) ]
  ! +               [ reduce using rule 44 (expr -> expr EQ expr .) ]
  ! -               [ reduce using rule 44 (expr -> expr EQ expr .) ]
  ! *               [ reduce using rule 44 (expr -> expr EQ expr .) ]
  ! /               [ reduce using rule 44 (expr -> expr EQ expr .) ]
  ! MPLUS           [ shift and go to state 39 ]
  ! MMINUS          [ shift and go to state 40 ]
  ! MTIMES          [ shift and go to state 41 ]
  ! MDIVIDE         [ shift and go to state 42 ]
  ! EQ              [ shift and go to state 43 ]
  ! NEQ             [ shift and go to state 44 ]
  ! >               [ shift and go to state 45 ]
  ! <               [ shift and go to state 46 ]
  ! LEQ             [ shift and go to state 47 ]
  ! GEQ             [ shift and go to state 48 ]


state 84

    (45) expr -> expr NEQ expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 45 (expr -> expr NEQ expr .)
    MPLUS           reduce using rule 45 (expr -> expr NEQ expr .)
    MMINUS          reduce using rule 45 (expr -> expr NEQ expr .)
    MTIMES          reduce using rule 45 (expr -> expr NEQ expr .)
    MDIVIDE         reduce using rule 45 (expr -> expr NEQ expr .)
    EQ              reduce using rule 45 (expr -> expr NEQ expr .)
    NEQ             reduce using rule 45 (expr -> expr NEQ expr .)
    >               reduce using rule 45 (expr -> expr NEQ expr .)
    <               reduce using rule 45 (expr -> expr NEQ expr .)
    LEQ             reduce using rule 45 (expr -> expr NEQ expr .)
    GEQ             reduce using rule 45 (expr -> expr NEQ expr .)
    )               reduce using rule 45 (expr -> expr NEQ expr .)
    ,               reduce using rule 45 (expr -> expr NEQ expr .)
    ]               reduce using rule 45 (expr -> expr NEQ expr .)
    :               reduce using rule 45 (expr -> expr NEQ expr .)
    {               reduce using rule 45 (expr -> expr NEQ expr .)
    BREAK           reduce using rule 45 (expr -> expr NEQ expr .)
    CONTINUE        reduce using rule 45 (expr -> expr NEQ expr .)
    IF              reduce using rule 45 (expr -> expr NEQ expr .)
    INTNUMBER       reduce using rule 45 (expr -> expr NEQ expr .)
    FLOATNUMBER     reduce using rule 45 (expr -> expr NEQ expr .)
    [               reduce using rule 45 (expr -> expr NEQ expr .)
    (               reduce using rule 45 (expr -> expr NEQ expr .)
    RETURN          reduce using rule 45 (expr -> expr NEQ expr .)
    PRINT           reduce using rule 45 (expr -> expr NEQ expr .)
    FOR             reduce using rule 45 (expr -> expr NEQ expr .)
    WHILE           reduce using rule 45 (expr -> expr NEQ expr .)
    ID              reduce using rule 45 (expr -> expr NEQ expr .)
    ZEROS           reduce using rule 45 (expr -> expr NEQ expr .)
    ONES            reduce using rule 45 (expr -> expr NEQ expr .)
    EYE             reduce using rule 45 (expr -> expr NEQ expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38

  ! '               [ reduce using rule 45 (expr -> expr NEQ expr .) ]
  ! +               [ reduce using rule 45 (expr -> expr NEQ expr .) ]
  ! -               [ reduce using rule 45 (expr -> expr NEQ expr .) ]
  ! *               [ reduce using rule 45 (expr -> expr NEQ expr .) ]
  ! /               [ reduce using rule 45 (expr -> expr NEQ expr .) ]
  ! MPLUS           [ shift and go to state 39 ]
  ! MMINUS          [ shift and go to state 40 ]
  ! MTIMES          [ shift and go to state 41 ]
  ! MDIVIDE         [ shift and go to state 42 ]
  ! EQ              [ shift and go to state 43 ]
  ! NEQ             [ shift and go to state 44 ]
  ! >               [ shift and go to state 45 ]
  ! <               [ shift and go to state 46 ]
  ! LEQ             [ shift and go to state 47 ]
  ! GEQ             [ shift and go to state 48 ]


state 85

    (46) expr -> expr > expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 46 (expr -> expr > expr .)
    MPLUS           reduce using rule 46 (expr -> expr > expr .)
    MMINUS          reduce using rule 46 (expr -> expr > expr .)
    MTIMES          reduce using rule 46 (expr -> expr > expr .)
    MDIVIDE         reduce using rule 46 (expr -> expr > expr .)
    EQ              reduce using rule 46 (expr -> expr > expr .)
    NEQ             reduce using rule 46 (expr -> expr > expr .)
    >               reduce using rule 46 (expr -> expr > expr .)
    <               reduce using rule 46 (expr -> expr > expr .)
    LEQ             reduce using rule 46 (expr -> expr > expr .)
    GEQ             reduce using rule 46 (expr -> expr > expr .)
    )               reduce using rule 46 (expr -> expr > expr .)
    ,               reduce using rule 46 (expr -> expr > expr .)
    ]               reduce using rule 46 (expr -> expr > expr .)
    :               reduce using rule 46 (expr -> expr > expr .)
    {               reduce using rule 46 (expr -> expr > expr .)
    BREAK           reduce using rule 46 (expr -> expr > expr .)
    CONTINUE        reduce using rule 46 (expr -> expr > expr .)
    IF              reduce using rule 46 (expr -> expr > expr .)
    INTNUMBER       reduce using rule 46 (expr -> expr > expr .)
    FLOATNUMBER     reduce using rule 46 (expr -> expr > expr .)
    [               reduce using rule 46 (expr -> expr > expr .)
    (               reduce using rule 46 (expr -> expr > expr .)
    RETURN          reduce using rule 46 (expr -> expr > expr .)
    PRINT           reduce using rule 46 (expr -> expr > expr .)
    FOR             reduce using rule 46 (expr -> expr > expr .)
    WHILE           reduce using rule 46 (expr -> expr > expr .)
    ID              reduce using rule 46 (expr -> expr > expr .)
    ZEROS           reduce using rule 46 (expr -> expr > expr .)
    ONES            reduce using rule 46 (expr -> expr > expr .)
    EYE             reduce using rule 46 (expr -> expr > expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38

  ! '               [ reduce using rule 46 (expr -> expr > expr .) ]
  ! +               [ reduce using rule 46 (expr -> expr > expr .) ]
  ! -               [ reduce using rule 46 (expr -> expr > expr .) ]
  ! *               [ reduce using rule 46 (expr -> expr > expr .) ]
  ! /               [ reduce using rule 46 (expr -> expr > expr .) ]
  ! MPLUS           [ shift and go to state 39 ]
  ! MMINUS          [ shift and go to state 40 ]
  ! MTIMES          [ shift and go to state 41 ]
  ! MDIVIDE         [ shift and go to state 42 ]
  ! EQ              [ shift and go to state 43 ]
  ! NEQ             [ shift and go to state 44 ]
  ! >               [ shift and go to state 45 ]
  ! <               [ shift and go to state 46 ]
  ! LEQ             [ shift and go to state 47 ]
  ! GEQ             [ shift and go to state 48 ]


state 86

    (47) expr -> expr < expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 47 (expr -> expr < expr .)
    MPLUS           reduce using rule 47 (expr -> expr < expr .)
    MMINUS          reduce using rule 47 (expr -> expr < expr .)
    MTIMES          reduce using rule 47 (expr -> expr < expr .)
    MDIVIDE         reduce using rule 47 (expr -> expr < expr .)
    EQ              reduce using rule 47 (expr -> expr < expr .)
    NEQ             reduce using rule 47 (expr -> expr < expr .)
    >               reduce using rule 47 (expr -> expr < expr .)
    <               reduce using rule 47 (expr -> expr < expr .)
    LEQ             reduce using rule 47 (expr -> expr < expr .)
    GEQ             reduce using rule 47 (expr -> expr < expr .)
    )               reduce using rule 47 (expr -> expr < expr .)
    ,               reduce using rule 47 (expr -> expr < expr .)
    ]               reduce using rule 47 (expr -> expr < expr .)
    :               reduce using rule 47 (expr -> expr < expr .)
    {               reduce using rule 47 (expr -> expr < expr .)
    BREAK           reduce using rule 47 (expr -> expr < expr .)
    CONTINUE        reduce using rule 47 (expr -> expr < expr .)
    IF              reduce using rule 47 (expr -> expr < expr .)
    INTNUMBER       reduce using rule 47 (expr -> expr < expr .)
    FLOATNUMBER     reduce using rule 47 (expr -> expr < expr .)
    [               reduce using rule 47 (expr -> expr < expr .)
    (               reduce using rule 47 (expr -> expr < expr .)
    RETURN          reduce using rule 47 (expr -> expr < expr .)
    PRINT           reduce using rule 47 (expr -> expr < expr .)
    FOR             reduce using rule 47 (expr -> expr < expr .)
    WHILE           reduce using rule 47 (expr -> expr < expr .)
    ID              reduce using rule 47 (expr -> expr < expr .)
    ZEROS           reduce using rule 47 (expr -> expr < expr .)
    ONES            reduce using rule 47 (expr -> expr < expr .)
    EYE             reduce using rule 47 (expr -> expr < expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38

  ! '               [ reduce using rule 47 (expr -> expr < expr .) ]
  ! +               [ reduce using rule 47 (expr -> expr < expr .) ]
  ! -               [ reduce using rule 47 (expr -> expr < expr .) ]
  ! *               [ reduce using rule 47 (expr -> expr < expr .) ]
  ! /               [ reduce using rule 47 (expr -> expr < expr .) ]
  ! MPLUS           [ shift and go to state 39 ]
  ! MMINUS          [ shift and go to state 40 ]
  ! MTIMES          [ shift and go to state 41 ]
  ! MDIVIDE         [ shift and go to state 42 ]
  ! EQ              [ shift and go to state 43 ]
  ! NEQ             [ shift and go to state 44 ]
  ! >               [ shift and go to state 45 ]
  ! <               [ shift and go to state 46 ]
  ! LEQ             [ shift and go to state 47 ]
  ! GEQ             [ shift and go to state 48 ]


state 87

    (48) expr -> expr LEQ expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 48 (expr -> expr LEQ expr .)
    MPLUS           reduce using rule 48 (expr -> expr LEQ expr .)
    MMINUS          reduce using rule 48 (expr -> expr LEQ expr .)
    MTIMES          reduce using rule 48 (expr -> expr LEQ expr .)
    MDIVIDE         reduce using rule 48 (expr -> expr LEQ expr .)
    EQ              reduce using rule 48 (expr -> expr LEQ expr .)
    NEQ             reduce using rule 48 (expr -> expr LEQ expr .)
    >               reduce using rule 48 (expr -> expr LEQ expr .)
    <               reduce using rule 48 (expr -> expr LEQ expr .)
    LEQ             reduce using rule 48 (expr -> expr LEQ expr .)
    GEQ             reduce using rule 48 (expr -> expr LEQ expr .)
    )               reduce using rule 48 (expr -> expr LEQ expr .)
    ,               reduce using rule 48 (expr -> expr LEQ expr .)
    ]               reduce using rule 48 (expr -> expr LEQ expr .)
    :               reduce using rule 48 (expr -> expr LEQ expr .)
    {               reduce using rule 48 (expr -> expr LEQ expr .)
    BREAK           reduce using rule 48 (expr -> expr LEQ expr .)
    CONTINUE        reduce using rule 48 (expr -> expr LEQ expr .)
    IF              reduce using rule 48 (expr -> expr LEQ expr .)
    INTNUMBER       reduce using rule 48 (expr -> expr LEQ expr .)
    FLOATNUMBER     reduce using rule 48 (expr -> expr LEQ expr .)
    [               reduce using rule 48 (expr -> expr LEQ expr .)
    (               reduce using rule 48 (expr -> expr LEQ expr .)
    RETURN          reduce using rule 48 (expr -> expr LEQ expr .)
    PRINT           reduce using rule 48 (expr -> expr LEQ expr .)
    FOR             reduce using rule 48 (expr -> expr LEQ expr .)
    WHILE           reduce using rule 48 (expr -> expr LEQ expr .)
    ID              reduce using rule 48 (expr -> expr LEQ expr .)
    ZEROS           reduce using rule 48 (expr -> expr LEQ expr .)
    ONES            reduce using rule 48 (expr -> expr LEQ expr .)
    EYE             reduce using rule 48 (expr -> expr LEQ expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38

  ! '               [ reduce using rule 48 (expr -> expr LEQ expr .) ]
  ! +               [ reduce using rule 48 (expr -> expr LEQ expr .) ]
  ! -               [ reduce using rule 48 (expr -> expr LEQ expr .) ]
  ! *               [ reduce using rule 48 (expr -> expr LEQ expr .) ]
  ! /               [ reduce using rule 48 (expr -> expr LEQ expr .) ]
  ! MPLUS           [ shift and go to state 39 ]
  ! MMINUS          [ shift and go to state 40 ]
  ! MTIMES          [ shift and go to state 41 ]
  ! MDIVIDE         [ shift and go to state 42 ]
  ! EQ              [ shift and go to state 43 ]
  ! NEQ             [ shift and go to state 44 ]
  ! >               [ shift and go to state 45 ]
  ! <               [ shift and go to state 46 ]
  ! LEQ             [ shift and go to state 47 ]
  ! GEQ             [ shift and go to state 48 ]


state 88

    (49) expr -> expr GEQ expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 49 (expr -> expr GEQ expr .)
    MPLUS           reduce using rule 49 (expr -> expr GEQ expr .)
    MMINUS          reduce using rule 49 (expr -> expr GEQ expr .)
    MTIMES          reduce using rule 49 (expr -> expr GEQ expr .)
    MDIVIDE         reduce using rule 49 (expr -> expr GEQ expr .)
    EQ              reduce using rule 49 (expr -> expr GEQ expr .)
    NEQ             reduce using rule 49 (expr -> expr GEQ expr .)
    >               reduce using rule 49 (expr -> expr GEQ expr .)
    <               reduce using rule 49 (expr -> expr GEQ expr .)
    LEQ             reduce using rule 49 (expr -> expr GEQ expr .)
    GEQ             reduce using rule 49 (expr -> expr GEQ expr .)
    )               reduce using rule 49 (expr -> expr GEQ expr .)
    ,               reduce using rule 49 (expr -> expr GEQ expr .)
    ]               reduce using rule 49 (expr -> expr GEQ expr .)
    :               reduce using rule 49 (expr -> expr GEQ expr .)
    {               reduce using rule 49 (expr -> expr GEQ expr .)
    BREAK           reduce using rule 49 (expr -> expr GEQ expr .)
    CONTINUE        reduce using rule 49 (expr -> expr GEQ expr .)
    IF              reduce using rule 49 (expr -> expr GEQ expr .)
    INTNUMBER       reduce using rule 49 (expr -> expr GEQ expr .)
    FLOATNUMBER     reduce using rule 49 (expr -> expr GEQ expr .)
    [               reduce using rule 49 (expr -> expr GEQ expr .)
    (               reduce using rule 49 (expr -> expr GEQ expr .)
    RETURN          reduce using rule 49 (expr -> expr GEQ expr .)
    PRINT           reduce using rule 49 (expr -> expr GEQ expr .)
    FOR             reduce using rule 49 (expr -> expr GEQ expr .)
    WHILE           reduce using rule 49 (expr -> expr GEQ expr .)
    ID              reduce using rule 49 (expr -> expr GEQ expr .)
    ZEROS           reduce using rule 49 (expr -> expr GEQ expr .)
    ONES            reduce using rule 49 (expr -> expr GEQ expr .)
    EYE             reduce using rule 49 (expr -> expr GEQ expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38

  ! '               [ reduce using rule 49 (expr -> expr GEQ expr .) ]
  ! +               [ reduce using rule 49 (expr -> expr GEQ expr .) ]
  ! -               [ reduce using rule 49 (expr -> expr GEQ expr .) ]
  ! *               [ reduce using rule 49 (expr -> expr GEQ expr .) ]
  ! /               [ reduce using rule 49 (expr -> expr GEQ expr .) ]
  ! MPLUS           [ shift and go to state 39 ]
  ! MMINUS          [ shift and go to state 40 ]
  ! MTIMES          [ shift and go to state 41 ]
  ! MDIVIDE         [ shift and go to state 42 ]
  ! EQ              [ shift and go to state 43 ]
  ! NEQ             [ shift and go to state 44 ]
  ! >               [ shift and go to state 45 ]
  ! <               [ shift and go to state 46 ]
  ! LEQ             [ shift and go to state 47 ]
  ! GEQ             [ shift and go to state 48 ]


state 89

    (53) ifstatement -> IF ( expr . ) morestatements
    (54) ifstatement -> IF ( expr . ) morestatements ELSE morestatements
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    )               shift and go to state 105
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 90

    (35) expr -> ( expr ) .

    ;               reduce using rule 35 (expr -> ( expr ) .)
    '               reduce using rule 35 (expr -> ( expr ) .)
    +               reduce using rule 35 (expr -> ( expr ) .)
    -               reduce using rule 35 (expr -> ( expr ) .)
    *               reduce using rule 35 (expr -> ( expr ) .)
    /               reduce using rule 35 (expr -> ( expr ) .)
    MPLUS           reduce using rule 35 (expr -> ( expr ) .)
    MMINUS          reduce using rule 35 (expr -> ( expr ) .)
    MTIMES          reduce using rule 35 (expr -> ( expr ) .)
    MDIVIDE         reduce using rule 35 (expr -> ( expr ) .)
    EQ              reduce using rule 35 (expr -> ( expr ) .)
    NEQ             reduce using rule 35 (expr -> ( expr ) .)
    >               reduce using rule 35 (expr -> ( expr ) .)
    <               reduce using rule 35 (expr -> ( expr ) .)
    LEQ             reduce using rule 35 (expr -> ( expr ) .)
    GEQ             reduce using rule 35 (expr -> ( expr ) .)
    )               reduce using rule 35 (expr -> ( expr ) .)
    ,               reduce using rule 35 (expr -> ( expr ) .)
    ]               reduce using rule 35 (expr -> ( expr ) .)
    :               reduce using rule 35 (expr -> ( expr ) .)
    {               reduce using rule 35 (expr -> ( expr ) .)
    BREAK           reduce using rule 35 (expr -> ( expr ) .)
    CONTINUE        reduce using rule 35 (expr -> ( expr ) .)
    IF              reduce using rule 35 (expr -> ( expr ) .)
    INTNUMBER       reduce using rule 35 (expr -> ( expr ) .)
    FLOATNUMBER     reduce using rule 35 (expr -> ( expr ) .)
    [               reduce using rule 35 (expr -> ( expr ) .)
    (               reduce using rule 35 (expr -> ( expr ) .)
    RETURN          reduce using rule 35 (expr -> ( expr ) .)
    PRINT           reduce using rule 35 (expr -> ( expr ) .)
    FOR             reduce using rule 35 (expr -> ( expr ) .)
    WHILE           reduce using rule 35 (expr -> ( expr ) .)
    ID              reduce using rule 35 (expr -> ( expr ) .)
    ZEROS           reduce using rule 35 (expr -> ( expr ) .)
    ONES            reduce using rule 35 (expr -> ( expr ) .)
    EYE             reduce using rule 35 (expr -> ( expr ) .)


state 91

    (21) assignstatement -> assignable = expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 21 (assignstatement -> assignable = expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 92

    (22) assignstatement -> assignable ASSIGNPLUS expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 22 (assignstatement -> assignable ASSIGNPLUS expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 93

    (23) assignstatement -> assignable ASSIGNMINUS expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 23 (assignstatement -> assignable ASSIGNMINUS expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 94

    (24) assignstatement -> assignable ASSIGNTIMES expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 24 (assignstatement -> assignable ASSIGNTIMES expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 95

    (25) assignstatement -> assignable ASSIGNDIVIDE expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ;               reduce using rule 25 (assignstatement -> assignable ASSIGNDIVIDE expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 96

    (60) matrixinitializer -> [ innerlist . ]
    (63) innerlist -> innerlist . , expr

    ]               shift and go to state 106
    ,               shift and go to state 107


state 97

    (62) innerlist -> expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ]               reduce using rule 62 (innerlist -> expr .)
    ,               reduce using rule 62 (innerlist -> expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 98

    (31) expr -> [ matrixinitializer ] .

    ;               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    '               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    +               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    -               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    *               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    /               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    MPLUS           reduce using rule 31 (expr -> [ matrixinitializer ] .)
    MMINUS          reduce using rule 31 (expr -> [ matrixinitializer ] .)
    MTIMES          reduce using rule 31 (expr -> [ matrixinitializer ] .)
    MDIVIDE         reduce using rule 31 (expr -> [ matrixinitializer ] .)
    EQ              reduce using rule 31 (expr -> [ matrixinitializer ] .)
    NEQ             reduce using rule 31 (expr -> [ matrixinitializer ] .)
    >               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    <               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    LEQ             reduce using rule 31 (expr -> [ matrixinitializer ] .)
    GEQ             reduce using rule 31 (expr -> [ matrixinitializer ] .)
    )               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    ,               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    ]               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    :               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    {               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    BREAK           reduce using rule 31 (expr -> [ matrixinitializer ] .)
    CONTINUE        reduce using rule 31 (expr -> [ matrixinitializer ] .)
    IF              reduce using rule 31 (expr -> [ matrixinitializer ] .)
    INTNUMBER       reduce using rule 31 (expr -> [ matrixinitializer ] .)
    FLOATNUMBER     reduce using rule 31 (expr -> [ matrixinitializer ] .)
    [               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    (               reduce using rule 31 (expr -> [ matrixinitializer ] .)
    RETURN          reduce using rule 31 (expr -> [ matrixinitializer ] .)
    PRINT           reduce using rule 31 (expr -> [ matrixinitializer ] .)
    FOR             reduce using rule 31 (expr -> [ matrixinitializer ] .)
    WHILE           reduce using rule 31 (expr -> [ matrixinitializer ] .)
    ID              reduce using rule 31 (expr -> [ matrixinitializer ] .)
    ZEROS           reduce using rule 31 (expr -> [ matrixinitializer ] .)
    ONES            reduce using rule 31 (expr -> [ matrixinitializer ] .)
    EYE             reduce using rule 31 (expr -> [ matrixinitializer ] .)


state 99

    (61) matrixinitializer -> matrixinitializer , . [ innerlist ]

    [               shift and go to state 108


state 100

    (32) expr -> specialmatrixword ( expr . )
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    )               shift and go to state 109
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 101

    (18) printables -> printables , . printable
    (19) printable -> . expr
    (20) printable -> . STRING
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    STRING          shift and go to state 70
    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    printable                      shift and go to state 110
    expr                           shift and go to state 69
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 102

    (57) forloop -> FOR ID = . rangeoperator morestatements
    (59) rangeoperator -> . expr : expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    rangeoperator                  shift and go to state 111
    expr                           shift and go to state 112
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 103

    (27) assignable -> ID [ expr . , expr ]
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ,               shift and go to state 113
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 104

    (58) whileloop -> WHILE ( expr . ) morestatements
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    )               shift and go to state 114
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 105

    (53) ifstatement -> IF ( expr ) . morestatements
    (54) ifstatement -> IF ( expr ) . morestatements ELSE morestatements
    (3) morestatements -> . statement
    (4) morestatements -> . statement morestatements
    (5) morestatements -> . { morestatements }
    (6) statement -> . ifstatement
    (7) statement -> . loop
    (8) statement -> . expr ;
    (9) statement -> . returnstatement ;
    (10) statement -> . assignstatement ;
    (11) statement -> . printstatement ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (53) ifstatement -> . IF ( expr ) morestatements
    (54) ifstatement -> . IF ( expr ) morestatements ELSE morestatements
    (55) loop -> . forloop
    (56) loop -> . whileloop
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (14) returnstatement -> . RETURN
    (15) returnstatement -> . RETURN expr
    (21) assignstatement -> . assignable = expr
    (22) assignstatement -> . assignable ASSIGNPLUS expr
    (23) assignstatement -> . assignable ASSIGNMINUS expr
    (24) assignstatement -> . assignable ASSIGNTIMES expr
    (25) assignstatement -> . assignable ASSIGNDIVIDE expr
    (16) printstatement -> . PRINT printables
    (57) forloop -> . FOR ID = rangeoperator morestatements
    (58) whileloop -> . WHILE ( expr ) morestatements
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    {               shift and go to state 4
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    IF              shift and go to state 13
    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    RETURN          shift and go to state 23
    PRINT           shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 27
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 7
    morestatements                 shift and go to state 115
    statement                      shift and go to state 3
    ifstatement                    shift and go to state 5
    loop                           shift and go to state 6
    returnstatement                shift and go to state 8
    assignstatement                shift and go to state 9
    printstatement                 shift and go to state 10
    forloop                        shift and go to state 15
    whileloop                      shift and go to state 16
    assignable                     shift and go to state 17
    specialmatrixword              shift and go to state 21

state 106

    (60) matrixinitializer -> [ innerlist ] .

    ]               reduce using rule 60 (matrixinitializer -> [ innerlist ] .)
    ,               reduce using rule 60 (matrixinitializer -> [ innerlist ] .)


state 107

    (63) innerlist -> innerlist , . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 116
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 108

    (61) matrixinitializer -> matrixinitializer , [ . innerlist ]
    (62) innerlist -> . expr
    (63) innerlist -> . innerlist , expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    innerlist                      shift and go to state 117
    expr                           shift and go to state 97
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 109

    (32) expr -> specialmatrixword ( expr ) .

    ;               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    '               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    +               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    -               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    *               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    /               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    MPLUS           reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    MMINUS          reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    MTIMES          reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    MDIVIDE         reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    EQ              reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    NEQ             reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    >               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    <               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    LEQ             reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    GEQ             reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    )               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    ,               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    ]               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    :               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    {               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    BREAK           reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    CONTINUE        reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    IF              reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    INTNUMBER       reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    FLOATNUMBER     reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    [               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    (               reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    RETURN          reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    PRINT           reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    FOR             reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    WHILE           reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    ID              reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    ZEROS           reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    ONES            reduce using rule 32 (expr -> specialmatrixword ( expr ) .)
    EYE             reduce using rule 32 (expr -> specialmatrixword ( expr ) .)


state 110

    (18) printables -> printables , printable .

    ,               reduce using rule 18 (printables -> printables , printable .)
    ;               reduce using rule 18 (printables -> printables , printable .)


state 111

    (57) forloop -> FOR ID = rangeoperator . morestatements
    (3) morestatements -> . statement
    (4) morestatements -> . statement morestatements
    (5) morestatements -> . { morestatements }
    (6) statement -> . ifstatement
    (7) statement -> . loop
    (8) statement -> . expr ;
    (9) statement -> . returnstatement ;
    (10) statement -> . assignstatement ;
    (11) statement -> . printstatement ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (53) ifstatement -> . IF ( expr ) morestatements
    (54) ifstatement -> . IF ( expr ) morestatements ELSE morestatements
    (55) loop -> . forloop
    (56) loop -> . whileloop
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (14) returnstatement -> . RETURN
    (15) returnstatement -> . RETURN expr
    (21) assignstatement -> . assignable = expr
    (22) assignstatement -> . assignable ASSIGNPLUS expr
    (23) assignstatement -> . assignable ASSIGNMINUS expr
    (24) assignstatement -> . assignable ASSIGNTIMES expr
    (25) assignstatement -> . assignable ASSIGNDIVIDE expr
    (16) printstatement -> . PRINT printables
    (57) forloop -> . FOR ID = rangeoperator morestatements
    (58) whileloop -> . WHILE ( expr ) morestatements
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    {               shift and go to state 4
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    IF              shift and go to state 13
    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    RETURN          shift and go to state 23
    PRINT           shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 27
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    morestatements                 shift and go to state 118
    statement                      shift and go to state 3
    ifstatement                    shift and go to state 5
    loop                           shift and go to state 6
    expr                           shift and go to state 7
    returnstatement                shift and go to state 8
    assignstatement                shift and go to state 9
    printstatement                 shift and go to state 10
    forloop                        shift and go to state 15
    whileloop                      shift and go to state 16
    assignable                     shift and go to state 17
    specialmatrixword              shift and go to state 21

state 112

    (59) rangeoperator -> expr . : expr
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    :               shift and go to state 119
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 113

    (27) assignable -> ID [ expr , . expr ]
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 120
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 114

    (58) whileloop -> WHILE ( expr ) . morestatements
    (3) morestatements -> . statement
    (4) morestatements -> . statement morestatements
    (5) morestatements -> . { morestatements }
    (6) statement -> . ifstatement
    (7) statement -> . loop
    (8) statement -> . expr ;
    (9) statement -> . returnstatement ;
    (10) statement -> . assignstatement ;
    (11) statement -> . printstatement ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (53) ifstatement -> . IF ( expr ) morestatements
    (54) ifstatement -> . IF ( expr ) morestatements ELSE morestatements
    (55) loop -> . forloop
    (56) loop -> . whileloop
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (14) returnstatement -> . RETURN
    (15) returnstatement -> . RETURN expr
    (21) assignstatement -> . assignable = expr
    (22) assignstatement -> . assignable ASSIGNPLUS expr
    (23) assignstatement -> . assignable ASSIGNMINUS expr
    (24) assignstatement -> . assignable ASSIGNTIMES expr
    (25) assignstatement -> . assignable ASSIGNDIVIDE expr
    (16) printstatement -> . PRINT printables
    (57) forloop -> . FOR ID = rangeoperator morestatements
    (58) whileloop -> . WHILE ( expr ) morestatements
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    {               shift and go to state 4
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    IF              shift and go to state 13
    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    RETURN          shift and go to state 23
    PRINT           shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 27
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 7
    morestatements                 shift and go to state 121
    statement                      shift and go to state 3
    ifstatement                    shift and go to state 5
    loop                           shift and go to state 6
    returnstatement                shift and go to state 8
    assignstatement                shift and go to state 9
    printstatement                 shift and go to state 10
    forloop                        shift and go to state 15
    whileloop                      shift and go to state 16
    assignable                     shift and go to state 17
    specialmatrixword              shift and go to state 21

state 115

    (53) ifstatement -> IF ( expr ) morestatements .
    (54) ifstatement -> IF ( expr ) morestatements . ELSE morestatements

    {               reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    BREAK           reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    CONTINUE        reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    IF              reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    INTNUMBER       reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    FLOATNUMBER     reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    [               reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    -               reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    (               reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    RETURN          reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    PRINT           reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    FOR             reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    WHILE           reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    ID              reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    ZEROS           reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    ONES            reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    EYE             reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    $end            reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    }               reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .)
    ELSE            shift and go to state 122

  ! ELSE            [ reduce using rule 53 (ifstatement -> IF ( expr ) morestatements .) ]


state 116

    (63) innerlist -> innerlist , expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ]               reduce using rule 63 (innerlist -> innerlist , expr .)
    ,               reduce using rule 63 (innerlist -> innerlist , expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 117

    (61) matrixinitializer -> matrixinitializer , [ innerlist . ]
    (63) innerlist -> innerlist . , expr

    ]               shift and go to state 123
    ,               shift and go to state 107


state 118

    (57) forloop -> FOR ID = rangeoperator morestatements .

    {               reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    BREAK           reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    CONTINUE        reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    IF              reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    INTNUMBER       reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    FLOATNUMBER     reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    [               reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    -               reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    (               reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    RETURN          reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    PRINT           reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    FOR             reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    WHILE           reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    ID              reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    ZEROS           reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    ONES            reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    EYE             reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    $end            reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    }               reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)
    ELSE            reduce using rule 57 (forloop -> FOR ID = rangeoperator morestatements .)


state 119

    (59) rangeoperator -> expr : . expr
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 124
    assignable                     shift and go to state 56
    specialmatrixword              shift and go to state 21

state 120

    (27) assignable -> ID [ expr , expr . ]
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

    ]               shift and go to state 125
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48


state 121

    (58) whileloop -> WHILE ( expr ) morestatements .

    {               reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    BREAK           reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    CONTINUE        reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    IF              reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    INTNUMBER       reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    FLOATNUMBER     reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    [               reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    -               reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    (               reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    RETURN          reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    PRINT           reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    FOR             reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    WHILE           reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    ID              reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    ZEROS           reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    ONES            reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    EYE             reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    $end            reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    }               reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)
    ELSE            reduce using rule 58 (whileloop -> WHILE ( expr ) morestatements .)


state 122

    (54) ifstatement -> IF ( expr ) morestatements ELSE . morestatements
    (3) morestatements -> . statement
    (4) morestatements -> . statement morestatements
    (5) morestatements -> . { morestatements }
    (6) statement -> . ifstatement
    (7) statement -> . loop
    (8) statement -> . expr ;
    (9) statement -> . returnstatement ;
    (10) statement -> . assignstatement ;
    (11) statement -> . printstatement ;
    (12) statement -> . BREAK ;
    (13) statement -> . CONTINUE ;
    (53) ifstatement -> . IF ( expr ) morestatements
    (54) ifstatement -> . IF ( expr ) morestatements ELSE morestatements
    (55) loop -> . forloop
    (56) loop -> . whileloop
    (28) expr -> . assignable
    (29) expr -> . INTNUMBER
    (30) expr -> . FLOATNUMBER
    (31) expr -> . [ matrixinitializer ]
    (32) expr -> . specialmatrixword ( expr )
    (33) expr -> . - expr
    (34) expr -> . expr '
    (35) expr -> . ( expr )
    (36) expr -> . expr + expr
    (37) expr -> . expr - expr
    (38) expr -> . expr * expr
    (39) expr -> . expr / expr
    (40) expr -> . expr MPLUS expr
    (41) expr -> . expr MMINUS expr
    (42) expr -> . expr MTIMES expr
    (43) expr -> . expr MDIVIDE expr
    (44) expr -> . expr EQ expr
    (45) expr -> . expr NEQ expr
    (46) expr -> . expr > expr
    (47) expr -> . expr < expr
    (48) expr -> . expr LEQ expr
    (49) expr -> . expr GEQ expr
    (14) returnstatement -> . RETURN
    (15) returnstatement -> . RETURN expr
    (21) assignstatement -> . assignable = expr
    (22) assignstatement -> . assignable ASSIGNPLUS expr
    (23) assignstatement -> . assignable ASSIGNMINUS expr
    (24) assignstatement -> . assignable ASSIGNTIMES expr
    (25) assignstatement -> . assignable ASSIGNDIVIDE expr
    (16) printstatement -> . PRINT printables
    (57) forloop -> . FOR ID = rangeoperator morestatements
    (58) whileloop -> . WHILE ( expr ) morestatements
    (26) assignable -> . ID
    (27) assignable -> . ID [ expr , expr ]
    (50) specialmatrixword -> . ZEROS
    (51) specialmatrixword -> . ONES
    (52) specialmatrixword -> . EYE

    {               shift and go to state 4
    BREAK           shift and go to state 11
    CONTINUE        shift and go to state 12
    IF              shift and go to state 13
    INTNUMBER       shift and go to state 18
    FLOATNUMBER     shift and go to state 19
    [               shift and go to state 20
    -               shift and go to state 22
    (               shift and go to state 14
    RETURN          shift and go to state 23
    PRINT           shift and go to state 24
    FOR             shift and go to state 25
    WHILE           shift and go to state 27
    ID              shift and go to state 26
    ZEROS           shift and go to state 28
    ONES            shift and go to state 29
    EYE             shift and go to state 30

    expr                           shift and go to state 7
    morestatements                 shift and go to state 126
    statement                      shift and go to state 3
    ifstatement                    shift and go to state 5
    loop                           shift and go to state 6
    returnstatement                shift and go to state 8
    assignstatement                shift and go to state 9
    printstatement                 shift and go to state 10
    forloop                        shift and go to state 15
    whileloop                      shift and go to state 16
    assignable                     shift and go to state 17
    specialmatrixword              shift and go to state 21

state 123

    (61) matrixinitializer -> matrixinitializer , [ innerlist ] .

    ]               reduce using rule 61 (matrixinitializer -> matrixinitializer , [ innerlist ] .)
    ,               reduce using rule 61 (matrixinitializer -> matrixinitializer , [ innerlist ] .)


state 124

    (59) rangeoperator -> expr : expr .
    (34) expr -> expr . '
    (36) expr -> expr . + expr
    (37) expr -> expr . - expr
    (38) expr -> expr . * expr
    (39) expr -> expr . / expr
    (40) expr -> expr . MPLUS expr
    (41) expr -> expr . MMINUS expr
    (42) expr -> expr . MTIMES expr
    (43) expr -> expr . MDIVIDE expr
    (44) expr -> expr . EQ expr
    (45) expr -> expr . NEQ expr
    (46) expr -> expr . > expr
    (47) expr -> expr . < expr
    (48) expr -> expr . LEQ expr
    (49) expr -> expr . GEQ expr

  ! shift/reduce conflict for - resolved as shift
    {               reduce using rule 59 (rangeoperator -> expr : expr .)
    BREAK           reduce using rule 59 (rangeoperator -> expr : expr .)
    CONTINUE        reduce using rule 59 (rangeoperator -> expr : expr .)
    IF              reduce using rule 59 (rangeoperator -> expr : expr .)
    INTNUMBER       reduce using rule 59 (rangeoperator -> expr : expr .)
    FLOATNUMBER     reduce using rule 59 (rangeoperator -> expr : expr .)
    [               reduce using rule 59 (rangeoperator -> expr : expr .)
    (               reduce using rule 59 (rangeoperator -> expr : expr .)
    RETURN          reduce using rule 59 (rangeoperator -> expr : expr .)
    PRINT           reduce using rule 59 (rangeoperator -> expr : expr .)
    FOR             reduce using rule 59 (rangeoperator -> expr : expr .)
    WHILE           reduce using rule 59 (rangeoperator -> expr : expr .)
    ID              reduce using rule 59 (rangeoperator -> expr : expr .)
    ZEROS           reduce using rule 59 (rangeoperator -> expr : expr .)
    ONES            reduce using rule 59 (rangeoperator -> expr : expr .)
    EYE             reduce using rule 59 (rangeoperator -> expr : expr .)
    '               shift and go to state 34
    +               shift and go to state 35
    -               shift and go to state 36
    *               shift and go to state 37
    /               shift and go to state 38
    MPLUS           shift and go to state 39
    MMINUS          shift and go to state 40
    MTIMES          shift and go to state 41
    MDIVIDE         shift and go to state 42
    EQ              shift and go to state 43
    NEQ             shift and go to state 44
    >               shift and go to state 45
    <               shift and go to state 46
    LEQ             shift and go to state 47
    GEQ             shift and go to state 48

  ! -               [ reduce using rule 59 (rangeoperator -> expr : expr .) ]


state 125

    (27) assignable -> ID [ expr , expr ] .

    =               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    ASSIGNPLUS      reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    ASSIGNMINUS     reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    ASSIGNTIMES     reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    ASSIGNDIVIDE    reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    ;               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    '               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    +               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    -               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    *               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    /               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    MPLUS           reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    MMINUS          reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    MTIMES          reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    MDIVIDE         reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    EQ              reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    NEQ             reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    >               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    <               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    LEQ             reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    GEQ             reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    )               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    ,               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    ]               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    :               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    {               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    BREAK           reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    CONTINUE        reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    IF              reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    INTNUMBER       reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    FLOATNUMBER     reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    [               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    (               reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    RETURN          reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    PRINT           reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    FOR             reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    WHILE           reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    ID              reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    ZEROS           reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    ONES            reduce using rule 27 (assignable -> ID [ expr , expr ] .)
    EYE             reduce using rule 27 (assignable -> ID [ expr , expr ] .)


state 126

    (54) ifstatement -> IF ( expr ) morestatements ELSE morestatements .

    {               reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    BREAK           reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    CONTINUE        reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    IF              reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    INTNUMBER       reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    FLOATNUMBER     reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    [               reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    -               reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    (               reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    RETURN          reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    PRINT           reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    FOR             reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    WHILE           reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    ID              reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    ZEROS           reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    ONES            reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    EYE             reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    $end            reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    }               reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)
    ELSE            reduce using rule 54 (ifstatement -> IF ( expr ) morestatements ELSE morestatements .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for { in state 3 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 3 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 3 resolved as shift
WARNING: shift/reduce conflict for IF in state 3 resolved as shift
WARNING: shift/reduce conflict for INTNUMBER in state 3 resolved as shift
WARNING: shift/reduce conflict for FLOATNUMBER in state 3 resolved as shift
WARNING: shift/reduce conflict for [ in state 3 resolved as shift
WARNING: shift/reduce conflict for - in state 3 resolved as shift
WARNING: shift/reduce conflict for ( in state 3 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 3 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 3 resolved as shift
WARNING: shift/reduce conflict for FOR in state 3 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 3 resolved as shift
WARNING: shift/reduce conflict for ID in state 3 resolved as shift
WARNING: shift/reduce conflict for ZEROS in state 3 resolved as shift
WARNING: shift/reduce conflict for ONES in state 3 resolved as shift
WARNING: shift/reduce conflict for EYE in state 3 resolved as shift
WARNING: shift/reduce conflict for [ in state 26 resolved as shift
WARNING: shift/reduce conflict for ' in state 79 resolved as shift
WARNING: shift/reduce conflict for + in state 79 resolved as shift
WARNING: shift/reduce conflict for - in state 79 resolved as shift
WARNING: shift/reduce conflict for * in state 79 resolved as shift
WARNING: shift/reduce conflict for / in state 79 resolved as shift
WARNING: shift/reduce conflict for MPLUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MMINUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MTIMES in state 79 resolved as shift
WARNING: shift/reduce conflict for MDIVIDE in state 79 resolved as shift
WARNING: shift/reduce conflict for EQ in state 79 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 79 resolved as shift
WARNING: shift/reduce conflict for > in state 79 resolved as shift
WARNING: shift/reduce conflict for < in state 79 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 79 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 79 resolved as shift
WARNING: shift/reduce conflict for ' in state 80 resolved as shift
WARNING: shift/reduce conflict for + in state 80 resolved as shift
WARNING: shift/reduce conflict for - in state 80 resolved as shift
WARNING: shift/reduce conflict for * in state 80 resolved as shift
WARNING: shift/reduce conflict for / in state 80 resolved as shift
WARNING: shift/reduce conflict for MPLUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MMINUS in state 80 resolved as shift
WARNING: shift/reduce conflict for MTIMES in state 80 resolved as shift
WARNING: shift/reduce conflict for MDIVIDE in state 80 resolved as shift
WARNING: shift/reduce conflict for EQ in state 80 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 80 resolved as shift
WARNING: shift/reduce conflict for > in state 80 resolved as shift
WARNING: shift/reduce conflict for < in state 80 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 80 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 80 resolved as shift
WARNING: shift/reduce conflict for ' in state 81 resolved as shift
WARNING: shift/reduce conflict for + in state 81 resolved as shift
WARNING: shift/reduce conflict for - in state 81 resolved as shift
WARNING: shift/reduce conflict for * in state 81 resolved as shift
WARNING: shift/reduce conflict for / in state 81 resolved as shift
WARNING: shift/reduce conflict for MPLUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MMINUS in state 81 resolved as shift
WARNING: shift/reduce conflict for MTIMES in state 81 resolved as shift
WARNING: shift/reduce conflict for MDIVIDE in state 81 resolved as shift
WARNING: shift/reduce conflict for EQ in state 81 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 81 resolved as shift
WARNING: shift/reduce conflict for > in state 81 resolved as shift
WARNING: shift/reduce conflict for < in state 81 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 81 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 81 resolved as shift
WARNING: shift/reduce conflict for ' in state 82 resolved as shift
WARNING: shift/reduce conflict for + in state 82 resolved as shift
WARNING: shift/reduce conflict for - in state 82 resolved as shift
WARNING: shift/reduce conflict for * in state 82 resolved as shift
WARNING: shift/reduce conflict for / in state 82 resolved as shift
WARNING: shift/reduce conflict for MPLUS in state 82 resolved as shift
WARNING: shift/reduce conflict for MMINUS in state 82 resolved as shift
WARNING: shift/reduce conflict for MTIMES in state 82 resolved as shift
WARNING: shift/reduce conflict for MDIVIDE in state 82 resolved as shift
WARNING: shift/reduce conflict for EQ in state 82 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 82 resolved as shift
WARNING: shift/reduce conflict for > in state 82 resolved as shift
WARNING: shift/reduce conflict for < in state 82 resolved as shift
WARNING: shift/reduce conflict for LEQ in state 82 resolved as shift
WARNING: shift/reduce conflict for GEQ in state 82 resolved as shift
WARNING: shift/reduce conflict for - in state 124 resolved as shift
